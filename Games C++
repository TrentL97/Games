#include <iostream>
#include <conio.h>
#include <time.h>
#include <Windows.h>
#include <deque>
#include <vector>
#include <iomanip>
#include <string>
#include <fcntl.h>
#include <io.h>
#include <stdio.h>
using namespace std;
bool bCheck = false;
bool wCheck = false;
bool bpCheck = false;
bool wpCheck = false;
const int rows = 8, columns = 8;
int board[rows][columns];
string z[rows][columns];
int q = 6, w = 0;
int wp1 = board[6][0] = 1;
int wp2 = board[6][1] = 2;
int wp3 = board[6][2] = 3;
int wp4 = board[6][3] = 4;
int wp5 = board[6][4] = 5;
int wp6 = board[6][5] = 6;
int wp7 = board[6][6] = 7;
int wp8 = board[6][7] = 8;
int wr1 = board[7][0] = 9;
int wn1 = board[7][1] = 10;
int wb1 = board[7][2] = 11;
int wq = board[7][3] = 12;
int wk = board[7][4] = 13;
int wb2 = board[7][5] = 14;
int wn2 = board[7][6] = 15;
int wr2 = board[7][7] = 16;
int bp1 = board[1][0] = 17;
int bp2 = board[1][1] = 18;
int bp3 = board[1][2] = 19;
int bp4 = board[1][3] = 20;
int bp5 = board[1][4] = 21;
int bp6 = board[1][5] = 22;
int bp7 = board[1][6] = 23;
int bp8 = board[1][7] = 24;
int br1 = board[0][0] = 25;
int bn1 = board[0][1] = 26;
int bb1 = board[0][2] = 27;
int bq = board[0][3] = 28;
int bk = board[0][4] = 29;
int bb2 = board[0][5] = 30;
int bn2 = board[0][6] = 31;
int br2 = board[0][7] = 32;
//Extras White: 33-64, Black: 70-101
//Displays the Manual
void manual()
{
	cout << "                                            WELCOME TO THE GAME OF CHESS                            "
		<< endl << "Player one starts the game on the bottom of the board and player two follows in this classic chess game." << endl <<
		"The objective of this game is to put the opponent's king in checkmate such that it is in check and unable to move."
		"Check is achieved by putting the opponent's king in the line of movement of your piece. The playere whose king" << endl << "is in check must"
		<< "subsequently get their king out of check by either moving their king from danger, taking the" << endl <<
		"imposing piece, or by shielding the king from the imposing piece " << endl << "Every piece has their own unique strengths "
		<< "and weaknesses as you will figure out in your advancement in chess." << endl << "The pawns, of which each player has 8, "
		<< "only moves forward at one space at a time." << endl << "They can only take opponent's pieces by moving"
		<< " diagonally forward (left or right)." << endl << "The rooks and bishop (2 per player) enjoy an unlimited range of movement, however; "
		<< endl << "the bishops can only move diagonally and the rooks move soley in the horizontal and vertical directions." << endl <<
		"The knights, of which there are also 2 per player, must move both horizontally and vertically." << endl << "This is accomplished by moving eiither "
		<< "1 or 2 spaces vertically, and then the by the other amount horizontally" << endl << "(for a total of three spaces"
		<< ", thus allowing for 8 combinations." << endl << "Each player has only one king and queen, both of which enjoy unlimited degrees of movement"
		<< "(diagonal and lateral)." << endl << "The queen is able to traverse any number of spaces while the king is limited to one space at a time."
		<< endl << endl <<
		"Gameplay:After one player completes their turn, the turn is automatically passed to the opponent." << endl << "At the start of the turn,"
		<< "the player chooses from a variety of keys to move their various pieces," << endl << "all of which are described in the legend."
		<< endl << "Alternatively: the player can press 'l' to pull up the legend, 'm' to pull up this maunual, 'n' to pull up the redacted" << endl
		<< "form of this manual (containing just the gameplay paragraph), or 'z' to leave the game." << endl << "Once the player has chosen a piece,"
		<< "they can enter 'p' if they need to change to a different piece." << endl;
	char c;
	cout << "Type any key to continue:";
	cin >> c;
}
//Displays the redacted manual
void redacted()
{
	cout << "Gameplay:After one player completes their turn, the turn is automatically passed to the opponent." << endl << "At the start of the turn, "
		<< "the player chooses from a variety of keys to move their various pieces," << endl << "all of which are described in the legend."
		<< endl << "Alternatively: the player can press 'l' to pull up the legend, 'm' to pull up this maunual, 'n' to pull up the redacted" << endl
		<< "form of this manual (containing just the gameplay paragraph), or 'z' to leave the game." << endl << "Once the player has chosen a piece,"
		<< "they can enter 'p' if they need to change to a different piece." << endl;
	char c;
	cout << "Type any key to continue:";
	cin >> c;
}
//Displays the legend
void legend()
{
	cout << "                                                  Legend:   Piece           Character        Key" << endl
		<< "                                                  Player1:  Pawn (1-8)        \x89              1-8      "
		<< "                                                                              Rook(L,R)     \\\\#/  \\#//         q d" << endl <<
		"                                                            Knight(L,R)      \xC8  \xC9            w s" << endl <<
		"                                                            Bishop(L,R)     \xC9  \xCC             e a" << endl <<
		"                                                            Queen            \xCE               r  " << endl <<
		"                                                            King              \xCB              t  " << endl << endl <<
		"                                                  Player2:  Pawn (1-8)         \x94             1-8 " << endl <<
		"                                                            Rook(L,R)      \\\\&/  \\&//        q d" << endl <<
		"                                                            Knight(L,R)      \xC0  \xDA            w s" << endl <<
		"                                                            Bishop(L,R)     \xB4  \xC3             e a" << endl <<
		"                                                            Queen            \xC5               r  " << endl <<
		"                                                            King              \xC2              t  " << endl << endl <<
		"               Hotkeys: L: Legend, M: Manual, N: Redacted manual, Z: Quit, P(in move): Choose different piece."
		<< endl;


}
//Set the display of the board
void display()
{
	/*for (int i = 0; i < rows; i++) {
	 for (int j = 0; j < columns; j++) {*/
	for (int i = 0; i < rows; i++)
	{
		for (int j = 0; j < columns; j++)
		{
			//The following statements set the display for the components of the chess board
			if (board[i][j] == 0)
				z[i][j] = ' ';
			else if (board[i][j] == 1)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				//_setmode(_fileno(stdout), _O_U16TEXT);
				z[i][j] = "\x89  ";
				//SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 47);
			}
			else if (board[i][j] == 2)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\x89  ";
				/*_setmode(_fileno(stdout), _O_U16TEXT);
				z[i][j] = wprintf(L"\263a");*/
			}
			else if (board[i][j] == 3)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\x89  ";
			}
			else if (board[i][j] == 4)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\x89  ";
			}
			else if (board[i][j] == 5)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\x89  ";
			}
			else if (board[i][j] == 6)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\x89  ";
			}
			else if (board[i][j] == 7)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\x89  ";
			}
			else if (board[i][j] == 8)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\x89  ";
			}
			else if (board[i][j] == 9)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\\\\#/ ";
				/*_setmode(_fileno(stdout), _O_U16TEXT);
				z[i][j] = wprintf(L"\263a");*/
			}
			else if (board[i][j] == 10)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\xC8  ";
			}
			else if (board[i][j] == 11)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\xB9  ";
			}
			else if (board[i][j] == 12)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\xCE ";
			}
			else if (board[i][j] == 13)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\xCB  ";
			}
			else if (board[i][j] == 14)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\xCC  ";
			}
			else if (board[i][j] == 15)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\xC9  ";
			}
			else if (board[i][j] == 16)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\\#//  ";
			}
			else if (board[i][j] == 17)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 6);
				z[i][j] = "\x94  ";
				//SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 47);
			}
			else if (board[i][j] == 18)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 12);
				z[i][j] = "\x94  ";
				/*_setmode(_fileno(stdout), _O_U16TEXT);
				z[i][j] = wprintf(L"\263a");*/
			}
			else if (board[i][j] == 19)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\x94  ";
			}
			else if (board[i][j] == 20)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\x94  ";
			}
			else if (board[i][j] == 21)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\x94  ";
			}
			else if (board[i][j] == 22)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\x94  ";
			}
			else if (board[i][j] == 23)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\x94  ";
			}
			else if (board[i][j] == 24)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\x94  ";
			}
			else if (board[i][j] == 25)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\\\\&/ ";
				/*_setmode(_fileno(stdout), _O_U16TEXT);
				z[i][j] = wprintf(L"\263a");*/
			}
			else if (board[i][j] == 26)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\xC0  ";
			}
			else if (board[i][j] == 27)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\xB4  ";
			}
			else if (board[i][j] == 28)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\xC5  ";
			}
			else if (board[i][j] == 29)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\xC2  ";
			}
			else if (board[i][j] == 30)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\xC3  ";
			}
			else if (board[i][j] == 31)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\xDA  ";
			}
			else if (board[i][j] == 32)
			{
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
				z[i][j] = "\\&//  ";
			}
			//Defines extra pieces (if a white pawn crosses the other side)
			for (int a = 33; a < 65; a++)
			{
				if (board[i][j] != a)
				{
					a++;
					a--;
				}
				else
				{
					if ((a) % 4 == 0)
					{
						SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
						z[i][j] = "\\\\#/  ";
					}
					else if ((a + 1) % 4 == 0)
					{
						SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
						z[i][j] = "\xC8  ";
					}
					else if ((a + 2) % 4 == 0)
					{
						SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
						z[i][j] = "\xB9  ";
					}
					else if ((a + 3) % 4 == 0)
					{
						SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
						z[i][j] = "\xCE  ";
					}
				}
			}
			//Defines extra pieces (if a black pawn crosses the other side)
			for (int a = 70; a < 102; a++)
			{
				if (board[i][j] != a)
				{
					a++;
					a--;
				}
				else
				{
					if ((a + 2) % 4 == 0)
					{
						SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
						z[i][j] = "\\\\&/  ";
					}
					else if ((a + 1) % 4 == 0)
					{
						SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
						z[i][j] = "\xC0  ";
					}
					else if (a % 4 == 0)
					{
						SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
						z[i][j] = "\xB4  ";
					}
					else if ((a - 1) % 4 == 0)
					{
						SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);
						z[i][j] = "\xC5  ";
					}
				}
			}
			if ((i + j) % 2 == 0)
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 112);
			else
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 7);
			cout << setw(5) << z[i][j];
		}
		cout << endl;
	}
}
//cont booleans allow the the game to switch turns, functions in game detect if a player successfully completed their turn or not
bool contb = false;
bool contw = false;
bool q1 = false;
bool q2 = false;
//pawn booleans and subsequent booleans alter the function of keys 1-8 (pawn keys) for both players later in the logic function
bool wpawn1 = false;
bool wpawn2 = false;
bool wpawn3 = false;
bool wpawn4 = false;
bool wpawn5 = false;
bool wpawn6 = false;
bool wpawn7 = false;
bool wpawn8 = false;
bool bpawn1 = false;
bool bpawn2 = false;
bool bpawn3 = false;
bool bpawn4 = false;
bool bpawn5 = false;
bool bpawn6 = false;
bool bpawn7 = false;
bool bpawn8 = false;
bool wrook1 = false;
bool wrook2 = false;
bool wrook3 = false;
bool wrook4 = false;
bool wrook5 = false;
bool wrook6 = false;
bool wrook7 = false;
bool wrook8 = false;
bool brook1 = false;
bool brook2 = false;
bool brook3 = false;
bool brook4 = false;
bool brook5 = false;
bool brook6 = false;
bool brook7 = false;
bool brook8 = false;
bool wknight1 = false;
bool wknight2 = false;
bool wknight3 = false;
bool wknight4 = false;
bool wknight5 = false;
bool wknight6 = false;
bool wknight7 = false;
bool wknight8 = false;
bool bknight1 = false;
bool bknight2 = false;
bool bknight3 = false;
bool bknight4 = false;
bool bknight5 = false;
bool bknight6 = false;
bool bknight7 = false;
bool bknight8 = false;
bool wbishop1 = false;
bool wbishop2 = false;
bool wbishop3 = false;
bool wbishop4 = false;
bool wbishop5 = false;
bool wbishop6 = false;
bool wbishop7 = false;
bool wbishop8 = false;
bool bbishop1 = false;
bool bbishop2 = false;
bool bbishop3 = false;
bool bbishop4 = false;
bool bbishop5 = false;
bool bbishop6 = false;
bool bbishop7 = false;
bool bbishop8 = false;
bool wqueen1 = false;
bool wqueen2 = false;
bool wqueen3 = false;
bool wqueen4 = false;
bool wqueen5 = false;
bool wqueen6 = false;
bool wqueen7 = false;
bool wqueen8 = false;
bool bqueen1 = false;
bool bqueen2 = false;
bool bqueen3 = false;
bool bqueen4 = false;
bool bqueen5 = false;
bool bqueen6 = false;
bool bqueen7 = false;
bool bqueen8 = false;
bool quitGame = false;
//Allows the user to quit
void quitC()
{
	char q = 0;
	cout << "Are you sure you want to quit? (Type y to leave game) :";
	cin >> q;
	if (q == 'y')
		quitGame = true;
	cout << "Quit" << quitGame;
}
//constantly checks if the white king is in check
void WhiteCheck()
{
	{
		wCheck = false;
		for (int i = 0; i < 8; i++)
		{
			for (int j = 0; j < 8; j++)
			{
				if (board[i][j] == 17 || board[i][j] == 18 || board[i][j] == 19 || board[i][j] == 20 ||
					board[i][j] == 21 || board[i][j] == 22 || board[i][j] == 23 || board[i][j] == 24) //Checks check from white pawns
				{
					if (board[i + 1][j - 1] == 13 && j - 1 >= 0)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
					if (board[i + 1][j + 1] == 13 && j + 1 <= 7)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
				}
				int q = 0, w = 0, e = 0, r = 0;
				if (board[i][j] == 32 || board[i][j] == 25) //Checks check from white rooks
				{
					for (q = 1; board[i - q][j] == 0; q++)
					{
						q = q;
					}
					for (w = 1; board[i + w][j] == 0; w++)
						w = w;
					for (e = 1; board[i][j - r] == 0; e++)
						e = e;
					for (r = 1; board[i][j + r] == 0; r++)
						r = r;
					if (board[i - q][j] == 13 && (i - q) >= 0)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
					if (board[i + w][j] == 13 && (i + w) <= 7)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
					if (board[i][j - e] == 13 && (j - e) >= 0)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
					if (board[i][j + r] == 13 && (j + r) <= 7)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
				}
				q = 0, w = 0, e = 0, r = 0;
				if (board[i][j] == 26 || board[i][j] == 31) //Checks check from white knights
				{
					if (board[i + 1][j + 2] == 13 && (i + 1) <= 7 && (j + 2) <= 7)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
					if (board[i + 1][j - 2] == 13 && (i + 1) <= 7 && (j - 2) >= 0)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
					if (board[i - 1][j + 2] == 13 && (i - 1) >= 0 && (j + 2) <= 7)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
					if (board[i - 1][j - 2] == 13 && (i - 1) >= 0 && (j - 2) >= 0)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
					if (board[i + 2][j + 1] == 13 && (i + 2) <= 7 && (j + 1) <= 7)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
					if (board[i + 2][j - 1] == 13 && (i + 2) <= 7 && (j - 1) >= 0)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
					if (board[i - 2][j + 1] == 13 && (i - 2) >= 0 && (j + 1) <= 7)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
					if (board[i - 2][j - 1] == 13 && (i - 2) >= 0 && (j - 1) >= 0)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
				}
				if (board[i][j] == 27 || board[i][j] == 30) //Checks check from white bishops
				{
					w = j - 1;
					for (q = i - 1; board[q][w] == 0; q--, w--)
					{
						if (board[q - 1][w - 1] == 13 && q >= 0 && w >= 0)
						{
							cout << "Check" << endl;
							bCheck = true;
						}
					}
					w = j - 1;
					for (q = i + 1; board[q][w] == 0; q++, w--)
					{
						if (board[q + 1][w - 1] == 13 && q + 1 <= 7 && w - 1 >= 0)
						{
							cout << "Check" << endl;
							bCheck = true;
						}
					}
					w = j + 1;
					for (q = i - 1; board[q][w] == 0; q--, w++)
					{
						if (board[q - 1][w + 1] == 13 && q - 1 >= 0 && w + 1 <= 7)
						{
							cout << "Check" << endl;
							bCheck = true;
						}
					}
					w = j + 1;
					for (q = i + 1; board[q][w] == 0; q++, w++)
					{
						if (board[q + 1][w + 1] == 13 && q + 1 <= 7 && w + 1 <= 7)
						{
							cout << "Check" << endl;
							bCheck = true;
						}
					}
				}
				if (board[i][j] == 28) //Checks check from the white queen
				{
					w = j - 1;
					for (q = i - 1; board[q][w] == 0; q--, w--)
					{
						if (board[q - 1][w - 1] == 13 && q - 1 >= 0 && w - 1 >= 0)
						{
							cout << "Check" << endl;
							bCheck = true;
						}
					}
					w = j - 1;
					for (q = i + 1; board[q][w] == 0; q++, w--)
					{
						if (board[q + 1][w - 1] == 13 && q - 1 <= 7 && w + 1 >= 0)
						{
							cout << "Check" << endl;
							bCheck = true;
						}
					}
					w = j + 1;
					for (q = i - 1; board[q][w] == 0; q--, w++)
					{
						if (board[q - 1][w + 1] == 13 && q - 1 >= 0 && w + 1 <= 7)
						{
							cout << "Check" << endl;
							bCheck = true;
						}
					}
					w = j + 1;
					for (q = i + 1; board[q][w] == 0; q++, w++)
					{
						if (board[q + 1][w + 1] == 13 && q + 1 <= 7 && w + 1 <= 7)
						{
							cout << "Check" << endl;
							bCheck = true;
						}
					}
					for (q = 1; board[i - q][j] == 0; q++)
						q = q;
					for (w = 1; board[i + w][j] == 0; w++)
						w = w;
					for (e = 1; board[i][j - e] == 0; e++)
						e = e;
					for (r = 1; board[i][j + r] == 0; r++)
						r = r;
					if (board[i - q][j] == 13 && (i - q) >= 0)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
					if (board[i + w][j] == 13 && (i + w) <= 7)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
					if (board[i][j - e] == 13 && (j - e) >= 0)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
					if (board[i][j + r] == 13 && (j + r) <= 7)
					{
						cout << "Check" << endl;
						bCheck = true;
					}

				}
			}
		}
	}
}
//constantly checks if the black king is in check
void BlackCheck()
{
	bCheck = false;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 1 || board[i][j] == 2 || board[i][j] == 3 || board[i][j] == 4 ||
				board[i][j] == 5 || board[i][j] == 6 || board[i][j] == 7 || board[i][j] == 8) //Checks check from white pawns
			{
				if (board[i - 1][j - 1] == 29 && j - 1 >= 0)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
				if (board[i - 1][j + 1] == 29 && j + 1 <= 7)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
			}
			int q = 0, w = 0, e = 0, r = 0;
			if (board[i][j] == 16 || board[i][j] == 9) //Checks check from white rooks
			{
				for (q = 1; board[i - q][j] == 0; q++)
				{
					q = q;
				}
				for (w = 1; board[i + w][j] == 0; w++)
					w = w;
				for (e = 1; board[i][j - r] == 0; e++)
					e = e;
				for (r = 1; board[i][j + r] == 0; r++)
					r = r;
				if (board[i - q][j] == 29 && (i - q) >= 0)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
				if (board[i + w][j] == 29 && (i + w) <= 7)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
				if (board[i][j - e] == 29 && (j - e) >= 0)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
				if (board[i][j + r] == 29 && (j + r) <= 7)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
			}
			q = 0, w = 0, e = 0, r = 0;
			if (board[i][j] == 10 || board[i][j] == 15) //Checks check from white knights
			{
				if (board[i + 1][j + 2] == 29 && (i + 1) <= 7 && (j + 2) <= 7)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
				if (board[i + 1][j - 2] == 29 && (i + 1) <= 7 && (j - 2) >= 0)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
				if (board[i - 1][j + 2] == 29 && (i - 1) >= 0 && (j + 2) <= 7)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
				if (board[i - 1][j - 2] == 29 && (i - 1) >= 0 && (j - 2) >= 0)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
				if (board[i + 2][j + 1] == 29 && (i + 2) <= 7 && (j + 1) <= 7)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
				if (board[i + 2][j - 1] == 29 && (i + 2) <= 7 && (j - 1) >= 0)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
				if (board[i - 2][j + 1] == 29 && (i - 2) >= 0 && (j + 1) <= 7)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
				if (board[i - 2][j - 1] == 29 && (i - 2) >= 0 && (j - 1) >= 0)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
			}
			if (board[i][j] == 11 || board[i][j] == 14) //Checks check from white bishops
			{
				w = j - 1;
				for (q = i - 1; board[q][w] == 0; q--, w--)
				{
					if (board[q - 1][w - 1] == 29 && q >= 0 && w >= 0)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
				}
				w = j - 1;
				for (q = i + 1; board[q][w] == 0; q++, w--)
				{
					if (board[q + 1][w - 1] == 29 && q + 1 <= 7 && w - 1 >= 0)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
				}
				w = j + 1;
				for (q = i - 1; board[q][w] == 0; q--, w++)
				{
					if (board[q - 1][w + 1] == 29 && q - 1 >= 0 && w + 1 <= 7)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
				}
				w = j + 1;
				for (q = i + 1; board[q][w] == 0; q++, w++)
				{
					if (board[q + 1][w + 1] == 29 && q + 1 <= 7 && w + 1 <= 7)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
				}
			}
			if (board[i][j] == 12) //Checks check from the white queen
			{
				w = j - 1;
				for (q = i - 1; board[q][w] == 0; q--, w--)
				{
					if (board[q - 1][w - 1] == 29 && q - 1 >= 0 && w - 1 >= 0)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
				}
				w = j - 1;
				for (q = i + 1; board[q][w] == 0; q++, w--)
				{
					if (board[q + 1][w - 1] == 29 && q - 1 <= 7 && w + 1 >= 0)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
				}
				w = j + 1;
				for (q = i - 1; board[q][w] == 0; q--, w++)
				{
					if (board[q - 1][w + 1] == 29 && q - 1 >= 0 && w + 1 <= 7)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
				}
				w = j + 1;
				for (q = i + 1; board[q][w] == 0; q++, w++)
				{
					if (board[q + 1][w + 1] == 29 && q + 1 <= 7 && w + 1 <= 7)
					{
						cout << "Check" << endl;
						bCheck = true;
					}
				}
				for (q = 1; board[i - q][j] == 0; q++)
					q = q;
				for (w = 1; board[i + w][j] == 0; w++)
					w = w;
				for (e = 1; board[i][j - e] == 0; e++)
					e = e;
				for (r = 1; board[i][j + r] == 0; r++)
					r = r;
				if (board[i - q][j] == 29 && (i - q) >= 0)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
				if (board[i + w][j] == 29 && (i + w) <= 7)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
				if (board[i][j - e] == 29 && (j - e) >= 0)
				{
					cout << "Check" << endl;
					bCheck = true;
				}
				if (board[i][j + r] == 29 && (j + r) <= 7)
				{
					cout << "Check" << endl;
					bCheck = true;
				}

			}
		}
	}
}
//Black Pawn (1)
void Bp1()
{
	bCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 17)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i + 1][j] == 0)
					center = 1;
				for (a = 1; a <= 12; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 14; a <= 16; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 33; a <= 64; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 1" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//The following if statements allows player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp1();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments; other such statements and loops will be used and defined at least once
							throughtout the code, and designated a name in parentheses*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i + 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j - 1] = 17;
							board[i][j] = 0;
							BlackCheck();
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j - 1] = q;
								board[i][j] = 17;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp1();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i + 1][j] = 17;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j] = 0;
								board[i][j] = 17;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp1();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i + 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j + 1] = 17;
							board[i][j] = 0;
							BlackCheck();
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j + 1] = q;
								board[i][j] = 17;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i + 1 != 7)
					contb = true;
				else if (i + 1 == 7)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 70;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 70;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 70;
							board[i][j] = 0;
						}
					}
					else if (c == 'n')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 71;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 71;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 71;
							board[i][j] = 0;
						}
					}
					else if (c == 'b')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 72;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 72;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 72;
							board[i][j] = 0;
						}
					}
					else if (c == 'q')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 73;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 73;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 73;
							board[i][j] = 0;
						}
					}
				}
				contb = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Bp2()
{
	bCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 18)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i + 1][j] == 0)
					center = 1;
				for (a = 1; a <= 12; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 14; a <= 16; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 33; a <= 64; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 2" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//THe followinf if statements allow player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp2();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i + 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j - 1] = 18;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j - 1] = q;
								board[i][j] = 18;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp2();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i + 1][j] = 18;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j] = 0;
								board[i][j] = 18;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp2();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i + 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j + 1] = 18;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j + 1] = q;
								board[i][j] = 18;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i + 1 != 7)
					contb = true;
				else if (i + 1 == 7)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 74;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 74;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 74;
							board[i][j] = 0;
						}
					}
					else if (c == 'n')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 75;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 75;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 75;
							board[i][j] = 0;
						}
					}
					else if (c == 'b')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 76;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 76;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 76;
							board[i][j] = 0;
						}
					}
					else if (c == 'q')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 77;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 77;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 77;
							board[i][j] = 0;
						}
					}
				}
				contb = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Bp3()
{
	bCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 19)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i + 1][j] == 0)
					center = 1;
				for (a = 1; a <= 12; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 14; a <= 16; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 33; a <= 64; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 3" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//The following if statements allow player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp3();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i + 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j - 1] = 19;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j - 1] = q;
								board[i][j] = 19;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp3();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i + 1][j] = 19;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j] = 0;
								board[i][j] = 19;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp3();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i + 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j + 1] = 19;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j + 1] = q;
								board[i][j] = 19;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i + 1 != 7)
					contb = true;
				else if (i + 1 == 7)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 78;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 78;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 78;
							board[i][j] = 0;
						}
					}
					else if (c == 'n')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 79;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 79;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 79;
							board[i][j] = 0;
						}
					}
					else if (c == 'b')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 80;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 80;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 80;
							board[i][j] = 0;
						}
					}
					else if (c == 'q')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 81;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 81;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 81;
							board[i][j] = 0;
						}
					}
				}
				contb = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Bp4()
{
	bCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 20)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i + 1][j] == 0)
					center = 1;
				for (a = 1; a <= 12; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 14; a <= 16; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 33; a <= 64; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 4" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//THe following if statements allows player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp4();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i + 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j - 1] = 20;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j - 1] = q;
								board[i][j] = 20;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp4();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i + 1][j] = 20;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j] = 0;
								board[i][j] = 20;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp4();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i + 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j + 1] = 20;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j + 1] = q;
								board[i][j] = 20;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				if (i + 1 != 7)
					contb = true;
				else if (i + 1 == 7)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 82;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 82;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 82;
							board[i][j] = 0;
						}
					}
					else if (c == 'n')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 83;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 83;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 83;
							board[i][j] = 0;
						}
					}
					else if (c == 'b')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 84;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 84;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 84;
							board[i][j] = 0;
						}
					}
					else if (c == 'q')
					{
						if (d == 'q')
						{
							board[i + 1][j - 1] = 85;
							board[i][j] = 0;
						}
						else if (d == 'w')
						{
							board[i + 1][j] = 85;
							board[i][j] = 0;
						}
						else if (d == 'e')
						{
							board[i + 1][j + 1] = 85;
							board[i][j] = 0;
						}
					}
				}
				contb = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Bp5()
{
	bCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 21)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i + 1][j] == 0)
					center = 1;
				for (a = 1; a <= 12; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 14; a <= 16; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 33; a <= 64; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 5" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//THe following if statements allows player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp5();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i + 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j - 1] = 21;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j - 1] = q;
								board[i][j] = 21;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp5();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i + 1][j] = 21;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j] = 0;
								board[i][j] = 21;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp5();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i + 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j + 1] = 21;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j + 1] = q;
								board[i][j] = 21;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i + 1 != 7)
					contb = true;
				else if (i + 1 == 7)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
						if (c == 'r')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 86;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 86;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 86;
								board[i][j] = 0;
							}
						}
						else if (c == 'n')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 87;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 87;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 87;
								board[i][j] = 0;
							}
						}
						else if (c == 'b')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 88;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 88;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 88;
								board[i][j] = 0;
							}
						}
						else if (c == 'q')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 89;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 89;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 89;
								board[i][j] = 0;
							}
						}
				}
				contb = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Bp6()
{
	bCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 22)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i + 1][j] == 0)
					center = 1;
				for (a = 1; a <= 12; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 14; a <= 16; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 33; a <= 64; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 6" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//The following if statements allows player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp6();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i + 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j - 1] = 22;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j - 1] = q;
								board[i][j] = 22;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp6();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i + 1][j] = 22;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j] = 0;
								board[i][j] = 22;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp6();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i + 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j + 1] = 22;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j + 1] = q;
								board[i][j] = 22;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i + 1 != 7)
					contb = true;
				else if (i + 1 == 7)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
						if (c == 'r')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 90;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 90;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 90;
								board[i][j] = 0;
							}
						}
						else if (c == 'n')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 91;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 91;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 91;
								board[i][j] = 0;
							}
						}
						else if (c == 'b')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 92;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 92;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 92;
								board[i][j] = 0;
							}
						}
						else if (c == 'q')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 93;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 93;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 93;
								board[i][j] = 0;
							}
						}
				}
				contb = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Bp7()
{
	bCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 23)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i + 1][j] == 0)
					center = 1;
				for (a = 1; a <= 12; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 14; a <= 16; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 33; a <= 64; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 7" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//THe following if statements allows player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp7();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i + 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j - 1] = 23;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j - 1] = q;
								board[i][j] = 23;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp7();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i + 1][j] = 23;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j] = 0;
								board[i][j] = 23;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp7();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i + 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j + 1] = 23;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j + 1] = q;
								board[i][j] = 23;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i + 1 != 7)
					contb = true;
				else if (i + 1 == 7)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
						if (c == 'r')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 94;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 94;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 94;
								board[i][j] = 0;
							}
						}
						else if (c == 'n')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 95;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 95;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 95;
								board[i][j] = 0;
							}
						}
						else if (c == 'b')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 96;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 96;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 96;
								board[i][j] = 0;
							}
						}
						else if (c == 'q')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 97;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 97;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 97;
								board[i][j] = 0;
							}
						}
				}
				contb = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Bp8()
{
	bCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 24)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i + 1][j] == 0)
					center = 1;
				for (a = 1; a <= 12; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 14; a <= 16; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 33; a <= 64; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i + 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i + 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 8" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//The following if statements allows player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp8();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i + 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j - 1] = 24;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j - 1] = q;
								board[i][j] = 24;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp8();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i + 1][j] = 24;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j] = 0;
								board[i][j] = 24;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Bp8();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i + 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i + 1][j + 1] = 24;
							board[i][j] = 0;
							BlackCheck();
							cout << "BCHECK:" << bCheck << endl;
							if (bCheck == false)
							{
								cout << "" << endl;
							}
							else if (bCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i + 1][j + 1] = q;
								board[i][j] = 24;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i + 1 != 7)
					contb = true;
				else if (i + 1 == 7)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
						if (c == 'r')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 98;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 98;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 98;
								board[i][j] = 0;
							}
						}
						else if (c == 'n')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 99;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 99;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 99;
								board[i][j] = 0;
							}
						}
						else if (c == 'b')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 100;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 100;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 100;
								board[i][j] = 0;
							}
						}
						else if (c == 'q')
						{
							if (d == 'q')
							{
								board[i + 1][j - 1] = 101;
								board[i][j] = 0;
							}
							else if (d == 'w')
							{
								board[i + 1][j] = 101;
								board[i][j] = 0;
							}
							else if (d == 'e')
							{
								board[i + 1][j + 1] = 101;
								board[i][j] = 0;
							}
						}
				}
				contb = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Wp1()
{
	wCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 1)//(locate)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i - 1][j] == 0)
					center = 1;
				for (a = 17; a <= 28; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 30; a <= 32; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 70; a <= 101; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 1" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//The following if statements allows player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp1();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i - 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j - 1] = 1;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j - 1] = q;
								board[i][j] = 1;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp1();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i - 1][j] = 1;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j] = 0;
								board[i][j] = 1;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp1();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i - 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j + 1] = 1;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j + 1] = q;
								board[i][j] = 1;
								i += 100;
								j += 100;
								d = 0;
								break;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i - 1 != 0)
					contw = true;
				else if (i - 1 == 0)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
					{
						board[i - 1][j] = 33;
						board[i][j] = 0;
					}
					else if (c == 'n')
					{
						board[i - 1][j] = 34;
						board[i][j] = 0;
					}
					else if (c == 'b')
					{
						board[i - 1][j] = 35;
						board[i][j] = 0;
					}
					else if (c == 'q')
					{
						board[i - 1][j] = 36;
						board[i][j] = 0;
					}
				}
				contw = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Wp2()
{
	wCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 2)//(locate)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i - 1][j] == 0)
					center = 1;
				for (a = 17; a <= 28; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 30; a <= 32; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 70; a <= 101; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 2" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//The following if statements allows player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp2();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i - 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j - 1] = 2;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j - 1] = q;
								board[i][j] = 2;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp2();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i - 1][j] = 2;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j] = 0;
								board[i][j] = 2;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp2();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i - 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j + 1] = 2;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j + 1] = q;
								board[i][j] = 2;
								i += 100;
								j += 100;
								d = 0;
								break;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i - 1 != 0)
					contw = true;
				else if (i - 1 == 0)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
					{
						board[i - 1][j] = 37;
						board[i][j] = 0;
					}
					else if (c == 'n')
					{
						board[i - 1][j] = 38;
						board[i][j] = 0;
					}
					else if (c == 'b')
					{
						board[i - 1][j] = 39;
						board[i][j] = 0;
					}
					else if (c == 'q')
					{
						board[i - 1][j] = 40;
						board[i][j] = 0;
					}
				}
				contw = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Wp3()
{
	wCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 3)//(locate)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i - 1][j] == 0)
					center = 1;
				for (a = 17; a <= 28; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 30; a <= 32; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 70; a <= 101; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 3" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//The following if statements allows player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp3();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i - 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j - 1] = 3;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j - 1] = q;
								board[i][j] = 3;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp3();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i - 1][j] = 3;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j] = 0;
								board[i][j] = 3;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp3();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i + 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j + 1] = 3;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j + 1] = q;
								board[i][j] = 3;
								i += 100;
								j += 100;
								d = 0;
								break;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i - 1 != 0)
					contw = true;
				else if (i - 1 == 0)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
					{
						board[i - 1][j] = 41;
						board[i][j] = 0;
					}
					else if (c == 'n')
					{
						board[i - 1][j] = 42;
						board[i][j] = 0;
					}
					else if (c == 'b')
					{
						board[i - 1][j] = 43;
						board[i][j] = 0;
					}
					else if (c == 'q')
					{
						board[i - 1][j] = 44;
						board[i][j] = 0;
					}
				}
				contw = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Wp4()
{
	wCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 4)//(locate)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i - 1][j] == 0)
					center = 1;
				for (a = 17; a <= 28; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 30; a <= 32; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 70; a <= 101; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 4" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//The following if statements allows player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp4();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i - 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j - 1] = 4;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j - 1] = q;
								board[i][j] = 4;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp4();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i - 1][j] = 4;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j] = 0;
								board[i][j] = 4;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp4();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i - 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j + 1] = 4;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j + 1] = q;
								board[i][j] = 4;
								i += 100;
								j += 100;
								d = 0;
								break;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i - 1 != 0)
					contw = true;
				else if (i - 1 == 0)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
					{
						board[i - 1][j] = 45;
						board[i][j] = 0;
					}
					else if (c == 'n')
					{
						board[i - 1][j] = 46;
						board[i][j] = 0;
					}
					else if (c == 'b')
					{
						board[i - 1][j] = 47;
						board[i][j] = 0;
					}
					else if (c == 'q')
					{
						board[i - 1][j] = 48;
						board[i][j] = 0;
					}
				}
				contw = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Wp5()
{
	wCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 5)//(locate)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i - 1][j] == 0)
					center = 1;
				for (a = 17; a <= 28; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 30; a <= 32; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 70; a <= 101; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 5" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//The following if statements allows player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp5();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i - 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j - 1] = 5;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j - 1] = q;
								board[i][j] = 5;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp5();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i - 1][j] = 5;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j] = 0;
								board[i][j] = 5;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp5();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i - 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j + 1] = 5;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j + 1] = q;
								board[i][j] = 5;
								i += 100;
								j += 100;
								d = 0;
								break;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i - 1 != 0)
					contw = true;
				else if (i - 1 == 0)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
					{
						board[i - 1][j] = 49;
						board[i][j] = 0;
					}
					else if (c == 'n')
					{
						board[i - 1][j] = 50;
						board[i][j] = 0;
					}
					else if (c == 'b')
					{
						board[i - 1][j] = 51;
						board[i][j] = 0;
					}
					else if (c == 'q')
					{
						board[i - 1][j] = 52;
						board[i][j] = 0;
					}
				}
				contw = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Wp6()
{
	wCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 6)//(locate)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i - 1][j] == 0)
					center = 1;
				for (a = 17; a <= 28; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 30; a <= 32; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 70; a <= 101; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 6" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//The following if statements allows player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp6();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i - 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j - 1] = 6;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j - 1] = q;
								board[i][j] = 6;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp6();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i - 1][j] = 6;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j] = 0;
								board[i][j] = 6;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp6();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i - 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j + 1] = 6;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j + 1] = q;
								board[i][j] = 6;
								i += 100;
								j += 100;
								d = 0;
								break;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i - 1 != 0)
					contw = true;
				else if (i - 1 == 0)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
					{
						board[i - 1][j] = 53;
						board[i][j] = 0;
					}
					else if (c == 'n')
					{
						board[i - 1][j] = 54;
						board[i][j] = 0;
					}
					else if (c == 'b')
					{
						board[i - 1][j] = 55;
						board[i][j] = 0;
					}
					else if (c == 'q')
					{
						board[i - 1][j] = 56;
						board[i][j] = 0;
					}
				}
				contw = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Wp7()
{
	wCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 7)//(locate)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i - 1][j] == 0)
					center = 1;
				for (a = 17; a <= 28; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 30; a <= 32; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 70; a <= 101; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 7" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//The following if statements allows player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp7();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i - 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j - 1] = 7;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j - 1] = q;
								board[i][j] = 7;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp7();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i - 1][j] = 7;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j] = 0;
								board[i][j] = 7;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp7();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i - 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j + 1] = 7;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j + 1] = q;
								board[i][j] = 7;
								i += 100;
								j += 100;
								d = 0;
								break;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i - 1 != 0)
					contw = true;
				else if (i - 1 == 0)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
					{
						board[i - 1][j] = 57;
						board[i][j] = 0;
					}
					else if (c == 'n')
					{
						board[i - 1][j] = 58;
						board[i][j] = 0;
					}
					else if (c == 'b')
					{
						board[i - 1][j] = 59;
						board[i][j] = 0;
					}
					else if (c == 'q')
					{
						board[i - 1][j] = 60;
						board[i][j] = 0;
					}
				}
				contw = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Wp8()
{
	wCheck = false;
	int q = 0;
	int token = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 8)//(locate)
			{
				int left = 0, right = 0, center = 0, a = 0;
				char d;
				if (board[i - 1][j] == 0)
					center = 1;
				for (a = 17; a <= 28; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 30; a <= 32; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				for (a = 70; a <= 101; a++) //Checks for enemy pieces to take (aside from king)
				{
					if (board[i - 1][j - 1] == a)
					{
						left = 1;
					}
					if (board[i - 1][j + 1] == a)
					{
						right = 1;
					}
				}
				if (j == 0) //If statements check for boundaries in pawn's direction of movement
					left = 0;
				if (j == 7)
					right = 0;
				cout << "Pawn 8" << endl;
				if (left == 0 && right == 0 && center == 0)//Returns if pawn is unable to move
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (left == 1 && right == 0 && center == 0)//If left is the only feasible direction
				{
					d = 'q';
				}
				if (left == 0 && right == 1 && center == 0)//If right is the only feasible direction
				{
					d = 'e';
				}
				if (left == 0 && right == 0 && center == 1)//If straight is the only feasible direction
				{
					d = 'w';
				}
				if (left == 1 && right == 1 && center == 0)//The following if statements allows player to choose direction of movement
				{
					cout << "Left or Right? (q,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 1 && center == 1)
				{
					cout << "Straight or Right? (w,e) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 0 && center == 1)
				{
					cout << "Left or Straight? (q,w) : " << endl;
					cin >> d;
				}
				if (left == 1 && right == 1 && center == 1)
				{
					cout << "Left, Right, or Straight? (q,w,e) : " << endl;
					cin >> d;
				}
				if (left == 0 && right == 0 && center == 0)
				{
					cout << "Cannot move.." << endl;
					return;
				}
				if (d == 'q')
				{
					if (left == 0) //Pawn cannot move left if no enemy piece lies to the left to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp8();
					}
					else if (left == 1)
					{
						{
							/*This set of for and if loops is used for every piece in the game and ensures that the player
							does not endanger their own king, by preliminarily proceeding with the move and calling the check function.
							If the the king is in check; the move is reversed and the cont boolean remains false, as the function doesn't
							execute to the end. It is used after all other preliminary checks (for boundary, friendly pieces, etc.) in every
							instance of piece movement. The for loop and int qare used to hold the place of whatever piece may getting taken by
							the piece of movement, while the if are used to either carry out the move or reverse the move using the q- value.
							denoted by (checkCheck) in comments*/
							for (int w = 0; w < 102; w++)
							{
								if (board[i - 1][j - 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j - 1] = 8;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j - 1] = q;
								board[i][j] = 8;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'w')
				{
					if (center == 0) //Pawn cannot move straight if the space ahead is not empty
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp8();
					}
					else if (center == 1)
					{
						{
							//(checkCheck)
							board[i - 1][j] = 8;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j] = 0;
								board[i][j] = 8;
								i += 100;
								j += 100;
								d = 0;
								return;
							}
						}
					}
				}
				if (d == 'e')
				{
					if (right == 0)//Pawns cannot move right if no enemy piece is located to the right to be taken
					{
						cout << "Invalid Move.." << endl;
						i += 100;
						j += 100;
						Wp8();
					}
					else if (right == 1)
					{
						{
							for (int w = 0; w < 102; w++) //(checkCheck)
							{
								if (board[i - 1][j + 1] == w)
								{
									q = w;
									break;
								}
							}
							board[i - 1][j + 1] = 8;
							board[i][j] = 0;
							WhiteCheck();
							if (wCheck == false)
							{
								cout << "" << endl;
							}
							else if (wCheck == true)
							{
								cout << "Cannot endanger the king!" << endl;
								board[i - 1][j + 1] = q;
								board[i][j] = 8;
								i += 100;
								j += 100;
								d = 0;
								break;
							}
						}
					}
				}
				//These if statements allow the player to choose a new piece if the board has been crossed, otherwise; the turn is passed
				else if (i - 1 != 0)
					contw = true;
				else if (i - 1 == 0)
				{
					char c;
					cout << "Choose a new piece: (r,n,b,q)" << endl;
					cin >> c;
					if (c == 'r')
					{
						board[i - 1][j] = 61;
						board[i][j] = 0;
					}
					else if (c == 'n')
					{
						board[i - 1][j] = 62;
						board[i][j] = 0;
					}
					else if (c == 'b')
					{
						board[i - 1][j] = 63;
						board[i][j] = 0;
					}
					else if (c == 'q')
					{
						board[i - 1][j] = 64;
						board[i][j] = 0;
					}
				}
				contw = true;
				i += 100;
				j += 100;
				d = 0;
			}
		}
	}
}
void Wrr()
{
	wCheck = false;
	bool qr = false;
	char d = 0;
	int n = 0, q = 0, a = 0, i = 0, j = 0, z = 0, f = 0, r = 0;
	int token = 0;
	cout << "Right Rook:" << endl;
	int count = 0;
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			if (board[i][j] == 16) //Locates rook (locate)
			{
				if (i - 1 < 0)
				{
					count++;
				}
				if (i + 1 > 7)
				{
					count++;
				}
				if (j - 1 < 0)
				{
					count++;
				}
				if (j + 1 > 7)
				{
					count++;
				}
				for (a = 1; a <= 16; a++)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
						{
							count++;
						}
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
						{
							count++;
						}
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
						{
							count++;
						}
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
						{
							count++;
						}
					}
				}
				for (a = 33; a <= 64; a++)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
						{
							count++;
						}
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
						{
							count++;
						}
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
						{
							count++;
						}
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
						{
							count++;
						}
					}
				}
				if (count >= 4)//Returns if there is nowhere to move (grounded)
				{
					cout << "Cannot move" << endl;
					i += 100;
					j += 100;
					return;
				}
				cout << "Direction (w,a,s,d) :";
				cin >> d;
				if (d == 'p')//If the player decides to move a different piece (rechoose)
					return;
				if (d != 'w' && d != 'a' && d != 's' && d != 'd')
				{
					cout << "Error invalid direction" << endl;
					Wrr();
				}
				cout << "How many spaces do you wish to move? :";
				cin >> n;
				if (n != 1 && n != 2 && n != 3 && n != 4 && n != 5 && n != 6 && n != 7 && n != 8)
				{
					cout << "Invalid entry" << endl;
					n = 0;
					return;
				}
				if (d == 'w')
				{
					cout << "Up" << endl;
					if (i - n < 0)//If the player chooses a range of movement that lies outside the chess board (boundary2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						Wrr();
					}
					for (q = i - 1; q >= (i - n + 1); q--)//If a piece lies inbetween the start point and the destination (overlap)
					{
						if (board[q][j] != 0)
						{
							cout << "Invalid Move" << endl;
							q -= 100;
							qr = true;
							i += 100;
							j += 100;
							Wrr();
						}
					}
					for (a = 1; a <= 16; a++)//2 for loops check for illegelly taking friendly pieces (friend)
					{
						if (board[i - n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrr();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i - n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrr();
						}
					}
					if (board[i - n][j] == 29)//Checks if an attempt is being made to take the king (takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Wrr();
					}
					if (qr == true)
						token = 0;
					else
						token = 1;
				}
				else if (d == 's')
				{
					cout << "Down:" << endl;
					if (i + n > 7)
					{
						cout << "Outside Map" << endl; //(boundary2)
						i += 100;
						j += 100;
						Wrr();
					}
					for (q = i + 1; q <= (i + n - 1); q++)
					{
						if (board[q][j] != 0)
						{
							cout << "Invalid Move" << endl;
							q += 100;
							qr = true;
							i += 100;
							j += 100;
							Wrr();
						}
					}
					for (a = 1; a <= 16; a++) //(friend)
					{
						if (board[i + n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrr();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i + n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrr();
						}
					}
					if (board[i + n][j] == 29) //(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Wrr();
					}
					if (qr == true)
						token = 0;
					else
						token = 2;
				}
				else if (d == 'a')
				{
					cout << "Left:" << endl;
					if (j - n < 0)
					{
						cout << "Outside Map" << endl; //(boundary2)
						i += 100;
						j += 100;
						Wrr();
					}
					for (q = j - 1; q >= (j - n + 1); q--)
					{
						if (board[i][q] != 0)//(overlap)
						{
							cout << "Invalid Move" << endl;
							q -= 100;
							qr = true;
							i += 100;
							j += 100;
							Wrr();
						}
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrr();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrr();
						}
					}
					if (board[i][j - n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Wrr();
					}
					if (qr == true)
						token = 0;
					else
						token = 3;
				}
				else if (d == 'd')
				{
					cout << "Right:" << endl;
					if (j + n > 7)//(boundary2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						Wrr();
					}
					for (q = j + 1; q <= (j + n - 1); q++)
					{
						if (board[i][q] != 0)//(overlap)
						{
							cout << "Invalid Move" << endl;
							q += 100;
							qr = true;
							i += 100;
							j += 100;
							Wrr();
						}
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrr();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrr();
						}
					}
					if (board[i][j + n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Wrr();
					}
					if (qr == true)
						token = 0;
					else
						token = 4;
				}
			}
			if (token == 1 && qr == false)
			{
				board[i - n][j] = 16;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i - n][j] == w)
					{
						r = w;
						break;
					}
				}
				WhiteCheck();
				if (wCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i - n][j] = r;
					board[i][j] = 16;
					return;
				}
				i += 100;
				j += 100;
				contw = true;
			}
			else if (token == 2 && qr == false)
			{
				board[i + n][j] = 16;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i + n][j] == w)
					{
						r = w;
						break;
					}
				}
				WhiteCheck();
				if (wCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i + n][j] = r;
					board[i][j] = 16;
					return;
				}
				i += 100;
				j += 100;
				contw = true;

			}
			else if (token == 3 && qr == false)
			{
				board[i][j - n] = 16;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i][j - n] == w)
					{
						r = w;
						break;
					}
				}
				WhiteCheck();
				if (wCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i][j - n] = r;
					board[i][j] = 16;
					return;
				}
				i += 100;
				j += 100;
				contw = true;
			}
			else if (token == 4 && qr == false)
			{
				board[i][j + n] = 16;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i][j + n] == w)
					{
						r = w;
						break;
					}
				}
				WhiteCheck();
				if (wCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i][j + n] = r;
					board[i][j] = 16;
					return;
				}
				i += 100;
				j += 100;
				contw = true;
			}
		}
	}
}
void Brr()
{
	bCheck = false;
	bool qr = false;
	char d = 0;
	int n = 0, q = 0, a = 0, i = 0, j = 0, z = 0, f = 0, r = 0;
	int token = 0;
	cout << "Right Rook:" << endl;
	int count = 0;
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			if (board[i][j] == 32) //Locates rook (locate)
			{
				if (i - 1 < 0)
				{
					count++;
				}
				if (i + 1 > 7)
				{
					count++;
				}
				if (j - 1 < 0)
				{
					count++;
				}
				if (j + 1 > 7)
				{
					count++;
				}
				for (a = 17; a <= 32; a++)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
						{
							count++;
						}
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
						{
							count++;
						}
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
						{
							count++;
						}
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
						{
							count++;
						}
					}
				}
				for (a = 70; a <= 101; a++)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
						{
							count++;
						}
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
						{
							count++;
						}
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
						{
							count++;
						}
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
						{
							count++;
						}
					}
				}
				if (count >= 4)//(grounded)
				{
					cout << "Cannot move" << endl;
					i += 100;
					j += 100;
					return;
				}
				cout << "Direction (w,a,s,d) :";
				cin >> d;
				if (d == 'p')//(rechoose)
					return;
				if (d != 'w' && d != 'a' && d != 's' && d != 'd')
				{
					cout << "Error invalid direction" << endl;
					Brr();
				}
				cout << "How many spaces do you wish to move? :";
				cin >> n;
				if (n != 1 && n != 2 && n != 3 && n != 4 && n != 5 && n != 6 && n != 7 && n != 8)
				{
					cout << "Invalid entry" << endl;
					n = 0;
					return;
				}
				if (d == 'w')
				{
					cout << "Up" << endl;
					if (i - n < 0)//(boundary2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						Brr();
					}
					for (q = i - 1; q >= (i - n + 1); q--)//(overlap)
					{
						if (board[q][j] != 0)
						{
							cout << "Invalid Move" << endl;
							q -= 100;
							qr = true;
							i += 100;
							j += 100;
							Brr();
						}
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i - n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brr();
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i - n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brr();
						}
					}
					if (board[i - n][j] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Brr();
					}
					if (qr == true)
						token = 0;
					else
						token = 1;
				}
				else if (d == 's')
				{
					cout << "Down:" << endl;
					if (i + n > 7)
					{
						cout << "Outside Map" << endl; //(boundary2)
						i += 100;
						j += 100;
						Brr();
					}
					for (q = i + 1; q <= (i + n - 1); q++)
					{
						if (board[q][j] != 0)
						{
							cout << "Invalid Move" << endl;
							q += 100;
							qr = true;
							i += 100;
							j += 100;
							Brr();
						}
					}
					for (a = 17; a <= 32; a++) //(friend)
					{
						if (board[i + n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brr();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i + n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brr();
						}
					}
					if (board[i + n][j] == 13) //(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Brr();
					}
					if (qr == true)
						token = 0;
					else
						token = 2;
				}
				else if (d == 'a')
				{
					cout << "Left:" << endl;
					if (j - n < 0)
					{
						cout << "Outside Map" << endl; //(boundary2)
						i += 100;
						j += 100;
						Brr();
					}
					for (q = j - 1; q >= (j - n + 1); q--)
					{
						if (board[i][q] != 0)//(overlap)
						{
							cout << "Invalid Move" << endl;
							q -= 100;
							qr = true;
							i += 100;
							j += 100;
							Brr();
						}
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brr();
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brr();
						}
					}
					if (board[i][j - n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Brr();
					}
					if (qr == true)
						token = 0;
					else
						token = 3;
				}
				else if (d == 'd')
				{
					cout << "Right:" << endl;
					if (j + n > 7)//(boundary2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						Brr();
					}
					for (q = j + 1; q <= (j + n - 1); q++)
					{
						if (board[i][q] != 0)//(overlap)
						{
							cout << "Invalid Move" << endl;
							q += 100;
							qr = true;
							i += 100;
							j += 100;
							Brr();
						}
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brr();
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brr();
						}
					}
					if (board[i][j + n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Brr();
					}
					if (qr == true)
						token = 0;
					else
						token = 4;
				}
			}
			if (token == 1 && qr == false)
			{
				board[i - n][j] = 32;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i - n][j] == w)
					{
						r = w;
						break;
					}
				}
				BlackCheck();
				if (bCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i - n][j] = r;
					board[i][j] = 32;
					return;
				}
				i += 100;
				j += 100;
				contb = true;
			}
			else if (token == 2 && qr == false)
			{
				board[i + n][j] = 32;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i + n][j] == w)
					{
						r = w;
						break;
					}
				}
				BlackCheck();
				if (bCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i + n][j] = r;
					board[i][j] = 32;
					return;
				}
				i += 100;
				j += 100;
				contb = true;

			}
			else if (token == 3 && qr == false)
			{
				board[i][j - n] = 32;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i][j - n] == w)
					{
						r = w;
						break;
					}
				}
				BlackCheck();
				if (bCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i][j - n] = r;
					board[i][j] = 32;
					return;
				}
				i += 100;
				j += 100;
				contb = true;
			}
			else if (token == 4 && qr == false)
			{
				board[i][j + n] = 32;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i][j + n] == w)
					{
						r = w;
						break;
					}
				}
				BlackCheck();
				if (bCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i][j + n] = r;
					board[i][j] = 32;
					return;
				}
				i += 100;
				j += 100;
				contb = true;
			}
		}
	}
}
void Wrl()
{
	wCheck = false;
	bool qr = false;
	char d = 0;
	int n = 0, q = 0, a = 0, i = 0, j = 0, z = 0, f = 0, r = 0;
	int token = 0;
	cout << "Left Rook:" << endl;
	int count = 0;
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			if (board[i][j] == 9) //(locate)
			{
				if (i - 1 < 0)
				{
					count++;
				}
				if (i + 1 > 7)
				{
					count++;
				}
				if (j - 1 < 0)
				{
					count++;
				}
				if (j + 1 > 7)
				{
					count++;
				}
				for (a = 1; a <= 16; a++)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
						{
							count++;
						}
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
						{
							count++;
						}
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
						{
							count++;
						}
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
						{
							count++;
						}
					}
				}
				for (a = 33; a <= 64; a++)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
						{
							count++;
						}
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
						{
							count++;
						}
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
						{
							count++;
						}
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
						{
							count++;
						}
					}
				}
				if (count >= 4)//(grounded)
				{
					cout << "Cannot move" << endl;
					i += 100;
					j += 100;
					return;
				}
				cout << "Direction (w,a,s,d) :";
				cin >> d;
				if (d == 'p')//(rechoose)
					return;
				if (d != 'w' && d != 'a' && d != 's' && d != 'd')
				{
					cout << "Error invalid direction" << endl;
					Wrl();
				}
				cout << "How many spaces do you wish to move? :";
				cin >> n;
				if (n != 1 && n != 2 && n != 3 && n != 4 && n != 5 && n != 6 && n != 7 && n != 8)
				{
					cout << "Invalid entry" << endl;
					n = 0;
					return;
				}
				if (d == 'w')
				{
					cout << "Up" << endl;
					if (i - n < 0)//(boundary2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						Wrl();
					}
					for (q = i - 1; q >= (i - n + 1); q--)//(overlap)
					{
						if (board[q][j] != 0)
						{
							cout << "Invalid Move" << endl;
							q -= 100;
							qr = true;
							i += 100;
							j += 100;
							Wrl();
						}
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i - n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrl();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i - n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrl();
						}
					}
					if (board[i - n][j] == 29)//Checks if an attempt is being made to take the king (takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Wrl();
					}
					if (qr == true)
						token = 0;
					else
						token = 1;
				}
				else if (d == 's')
				{
					cout << "Down:" << endl;
					if (i + n > 7)
					{
						cout << "Outside Map" << endl; //(boundary2)
						i += 100;
						j += 100;
						Wrl();
					}
					for (q = i + 1; q <= (i + n - 1); q++)
					{
						if (board[q][j] != 0)
						{
							cout << "Invalid Move" << endl;
							q += 100;
							qr = true;
							i += 100;
							j += 100;
							Wrl();
						}
					}
					for (a = 1; a <= 16; a++) //(friend)
					{
						if (board[i + n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrl();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i + n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrl();
						}
					}
					if (board[i + n][j] == 29) //(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Wrl();
					}
					if (qr == true)
						token = 0;
					else
						token = 2;
				}
				else if (d == 'a')
				{
					cout << "Left:" << endl;
					if (j - n < 0)
					{
						cout << "Outside Map" << endl; //(boundary2)
						i += 100;
						j += 100;
						Wrl();
					}
					for (q = j - 1; q >= (j - n + 1); q--)
					{
						if (board[i][q] != 0)//(overlap)
						{
							cout << "Invalid Move" << endl;
							q -= 100;
							qr = true;
							i += 100;
							j += 100;
							Wrl();
						}
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrl();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrl();
						}
					}
					if (board[i][j - n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Wrl();
					}
					if (qr == true)
						token = 0;
					else
						token = 3;
				}
				else if (d == 'd')
				{
					cout << "Right:" << endl;
					if (j + n > 7)//(boundary2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						Wrl();
					}
					for (q = j + 1; q <= (j + n - 1); q++)
					{
						if (board[i][q] != 0)//(overlap)
						{
							cout << "Invalid Move" << endl;
							q += 100;
							qr = true;
							i += 100;
							j += 100;
							Wrl();
						}
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrl();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Wrl();
						}
					}
					if (board[i][j + n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Wrl();
					}
					if (qr == true)
						token = 0;
					else
						token = 4;
				}
			}
			if (token == 1 && qr == false)
			{
				board[i - n][j] = 9;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i - n][j] == w)
					{
						r = w;
						break;
					}
				}
				WhiteCheck();
				if (wCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i - n][j] = r;
					board[i][j] = 9;
					return;
				}
				i += 100;
				j += 100;
				contw = true;
			}
			else if (token == 2 && qr == false)
			{
				board[i + n][j] = 9;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i + n][j] == w)
					{
						r = w;
						break;
					}
				}
				WhiteCheck();
				if (wCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i + n][j] = r;
					board[i][j] = 9;
					return;
				}
				i += 100;
				j += 100;
				contw = true;

			}
			else if (token == 3 && qr == false)
			{
				board[i][j - n] = 9;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i][j - n] == w)
					{
						r = w;
						break;
					}
				}
				WhiteCheck();
				if (wCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i][j - n] = r;
					board[i][j] = 9;
					return;
				}
				i += 100;
				j += 100;
				contw = true;
			}
			else if (token == 4 && qr == false)
			{
				board[i][j + n] = 9;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i][j + n] == w)
					{
						r = w;
						break;
					}
				}
				WhiteCheck();
				if (wCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i][j + n] = r;
					board[i][j] = 9;
					return;
				}
				i += 100;
				j += 100;
				contw = true;
			}
		}
	}
}
void Brl()
{
	wCheck = false;
	bool qr = false;
	char d = 0;
	int n = 0, q = 0, a = 0, i = 0, j = 0, z = 0, f = 0, r = 0;
	int token = 0;
	cout << "Left Rook:" << endl;
	int count = 0;
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			if (board[i][j] == 25) //Locates rook (locate)
			{
				if (i - 1 < 0)
				{
					count++;
				}
				if (i + 1 > 7)
				{
					count++;
				}
				if (j - 1 < 0)
				{
					count++;
				}
				if (j + 1 > 7)
				{
					count++;
				}
				for (a = 17; a <= 32; a++)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
						{
							count++;
						}
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
						{
							count++;
						}
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
						{
							count++;
						}
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
						{
							count++;
						}
					}
				}
				for (a = 70; a <= 101; a++)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
						{
							count++;
						}
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
						{
							count++;
						}
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
						{
							count++;
						}
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
						{
							count++;
						}
					}
				}
				if (count >= 4)//(grounded)
				{
					cout << "Cannot move" << endl;
					i += 100;
					j += 100;
					return;
				}
				cout << "Direction (w,a,s,d) :";
				cin >> d;
				if (d == 'p')//(rechoose)
					return;
				if (d != 'w' && d != 'a' && d != 's' && d != 'd')
				{
					cout << "Error invalid direction" << endl;
					Brl();
				}
				cout << "How many spaces do you wish to move? :";
				cin >> n;
				if (n != 1 && n != 2 && n != 3 && n != 4 && n != 5 && n != 6 && n != 7 && n != 8)
				{
					cout << "Invalid entry" << endl;
					n = 0;
					return;
				}
				if (d == 'w')
				{
					cout << "Up" << endl;
					if (i - n < 0)//(boundary2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						Brl();
					}
					for (q = i - 1; q >= (i - n + 1); q--)//(overlap)
					{
						if (board[q][j] != 0)
						{
							cout << "Invalid Move" << endl;
							q -= 100;
							qr = true;
							i += 100;
							j += 100;
							Brl();
						}
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i - n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brl();
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i - n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brl();
						}
					}
					if (board[i - n][j] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Brl();
					}
					if (qr == true)
						token = 0;
					else
						token = 1;
				}
				else if (d == 's')
				{
					cout << "Down:" << endl;
					if (i + n > 7)
					{
						cout << "Outside Map" << endl; //(boundary2)
						i += 100;
						j += 100;
						Brl();
					}
					for (q = i + 1; q <= (i + n - 1); q++)
					{
						if (board[q][j] != 0)
						{
							cout << "Invalid Move" << endl;
							q += 100;
							qr = true;
							i += 100;
							j += 100;
							Brl();
						}
					}
					for (a = 17; a <= 32; a++) //(friend)
					{
						if (board[i + n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brl();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i + n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brl();
						}
					}
					if (board[i + n][j] == 13) //(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Brl();
					}
					if (qr == true)
						token = 0;
					else
						token = 2;
				}
				else if (d == 'a')
				{
					cout << "Left:" << endl;
					if (j - n < 0)
					{
						cout << "Outside Map" << endl; //(boundary2)
						i += 100;
						j += 100;
						Brl();
					}
					for (q = j - 1; q >= (j - n + 1); q--)
					{
						if (board[i][q] != 0)//(overlap)
						{
							cout << "Invalid Move" << endl;
							q -= 100;
							qr = true;
							i += 100;
							j += 100;
							Brl();
						}
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brl();
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brl();
						}
					}
					if (board[i][j - n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Brl();
					}
					if (qr == true)
						token = 0;
					else
						token = 3;
				}
				else if (d == 'd')
				{
					cout << "Right:" << endl;
					if (j + n > 7)//(boundary2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						Brl();
					}
					for (q = j + 1; q <= (j + n - 1); q++)
					{
						if (board[i][q] != 0)//(overlap)
						{
							cout << "Invalid Move" << endl;
							q += 100;
							qr = true;
							i += 100;
							j += 100;
							Brl();
						}
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brl();
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							Brl();
						}
					}
					if (board[i][j + n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						Brl();
					}
					if (qr == true)
						token = 0;
					else
						token = 4;
				}
			}
			if (token == 1 && qr == false)
			{
				board[i - n][j] = 25;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i - n][j] == w)
					{
						r = w;
						break;
					}
				}
				BlackCheck();
				if (bCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i - n][j] = r;
					board[i][j] = 25;
					return;
				}
				i += 100;
				j += 100;
				contb = true;
			}
			else if (token == 2 && qr == false)
			{
				board[i + n][j] = 25;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i + n][j] == w)
					{
						r = w;
						break;
					}
				}
				BlackCheck();
				if (bCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i + n][j] = r;
					board[i][j] = 25;
					return;
				}
				i += 100;
				j += 100;
				contb = true;

			}
			else if (token == 3 && qr == false)
			{
				board[i][j - n] = 25;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i][j - n] == w)
					{
						r = w;
						break;
					}
				}
				BlackCheck();
				if (bCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i][j - n] = r;
					board[i][j] = 25;
					return;
				}
				i += 100;
				j += 100;
				contb = true;
			}
			else if (token == 4 && qr == false)
			{
				board[i][j + n] = 25;
				board[i][j] = 0;
				for (int w = 0; w < 102; w++)//(checkCheck)
				{
					if (board[i][j + n] == w)
					{
						r = w;
						break;
					}
				}
				BlackCheck();
				if (bCheck == true)
				{
					cout << "Cannot endanger the king!" << endl;
					board[i][j + n] = r;
					board[i][j] = 25;
					return;
				}
				i += 100;
				j += 100;
				contb = true;
			}
		}
	}
}
void Wnr()
{
	cout << "Right Knight" << endl;
	cout << "Direction (q,w,a,s) :";
	char d;
	cin >> d;
	if (d == 'p')
		return;
	int token = 0;
	int a, count = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 15)//(locate)
			{
				for (a = 1; a <= 16; a++)
				{
					if (board[i - 2][j - 1] == a || board[i - 1][j - 2] == a || board[i + 2][j - 1] == a || board[i + 1][j - 2] == a ||
						board[i - 1][j + 2] == a || board[i - 2][j + 1] == a || board[i + 2][j + 1] == a || board[i + 1][j + 2] == a)
					{
						count++;
					}
				}
				for (a = 33; a <= 64; a++)
				{
					if (board[i - 2][j - 1] == a || board[i - 1][j - 2] == a || board[i + 2][j - 1] == a || board[i + 1][j - 2] == a ||
						board[i - 1][j + 2] == a || board[i - 2][j + 1] == a || board[i + 2][j + 1] == a || board[i + 1][j + 2] == a)
					{
						count++;
					}
				}
				if (i - 1 < 0)
					count++;
				if (j - 1 < 0)
					count++;
				if (i - 2 < 0)
					count++;
				if (j - 2 < 0)
					count++;
				if (i + 1 > 7)
					count++;
				if (j + 1 > 7)
					count++;
				if (i + 2 > 7)
					count++;
				if (j + 2 > 7)
					count++;
				if (count >= 8)//(grounded)
				{
					cout << "Unable to move" << endl;
					return;
				}
				if (d == 'q')
				{
					cout << "Major Up or Left (u,l) : ";
					char q;
					cin >> q;
					if (q == 'u')
					{
						if (i - 2 < 0 || j - 1 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						for (a = 1; a <= 16; a++)//(friend)
						{
							if (board[i - 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i - 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						if (board[i - 2][j - 1] == 29)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 1;
					}
					else if (q == 'l')
					{
						if (i - 1 < 0 || j - 2 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						for (a = 1; a <= 16; a++)//(friend)
						{
							if (board[i - 1][j - 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i - 1][j - 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						if (board[i - 1][j - 2] == 29)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 2;
					}
				}
				else if (d == 'w')
				{
					cout << "Major Up or Right (u,r) :";
					char q;
					cin >> q;
					if (q == 'u')
					{
						if (i - 2 < 0 || j + 1 > 7)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						for (a = 1; a <= 16; a++)//(freind)
						{
							if (board[i - 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i - 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						if (board[i - 2][j + 1] == 29)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 3;
					}
					else if (q == 'r')
					{
						if (i - 1 < 0 || j + 2 > 7)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						for (a = 1; a <= 16; a++)
						{
							if (board[i - 1][j + 2] == a)//(friend)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i - 1][j + 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						if (board[i - 1][j + 2] == 29)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 4;
					}
				}
				else if (d == 'a')
				{
					cout << "Major Down or Left (d,l) : ";
					char a;
					cin >> a;
					if (a == 'd')
					{
						if (i + 2 > 7 || j - 1 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						for (a = 1; a <= 16; a++)//(friend)
						{
							if (board[i + 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i + 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						if (board[i + 2][j - 1] == 29)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 5;
					}
					else if (a == 'l')
					{
						if (i + 1 > 7 || j - 2 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						for (a = 1; a <= 16; a++)
						{
							if (board[i + 1][j - 2] == a)//(friend)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i + 1][j - 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						if (board[i + 1][j - 2] == 29)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 6;
					}
				}
				else if (d == 's')
				{
					cout << "Major Down or Right (d,r) : ";
					char q;
					cin >> q;
					if (q == 'd')//(boundary2)
					{
						if (i + 2 > 7 || j + 1 > 7)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						for (a = 1; a <= 16; a++)//(friend)
						{
							if (board[i + 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i + 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						if (board[i + 2][j + 1] == 29)//takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 7;
					}
					else if (q == 'r')
					{
						if (i + 1 > 7 || j + 2 > 7)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						for (a = 1; a <= 16; a++)
						{
							if (board[i + 1][j + 2] == a)//(friend)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i + 1][j + 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnr();
							}
						}
						if (board[i + 1][j + 2] == 29)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 8;
					}
				}
				int r = 0;
				if (token == 1)
				{
					board[i - 2][j - 1] = 15;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 2][j - 1] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 2][j - 1] = r;
						board[i][j] = 15;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 2)
				{
					board[i - 1][j - 2] = 15;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 1][j - 2] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 1][j - 2] = r;
						board[i][j] = 15;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 3)
				{
					board[i - 2][j + 1] = 15;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 2][j + 1] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 2][j + 1] = r;
						board[i][j] = 15;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 4)
				{
					board[i - 1][j + 2] = 15;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 1][j + 2] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 1][j + 2] = r;
						board[i][j] = 15;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 5)
				{
					board[i + 2][j - 1] = 15;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + 2][j - 1] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 2][j - 1] = r;
						board[i][j] = 15;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 6)
				{
					board[i + 1][j - 2] = 15;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + 1][j - 2] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 1][j - 2] = r;
						board[i][j] = 15;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 7)//(checkCheck)
				{
					board[i + 2][j + 1] = 15;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)
					{
						if (board[i + 2][j + 1] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 2][j + 1] = r;
						board[i][j] = 15;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 8)//(checkCheck)
				{
					board[i + 1][j + 2] = 15;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)
					{
						if (board[i + 1][j + 2] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 1][j + 2] = r;
						board[i][j] = 15;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
			}
		}
	}
}
void Bnr()
{
	cout << "Right Knight" << endl;
	cout << "Direction (q,w,a,s) :";
	char d;
	cin >> d;
	if (d == 'p')
		return;
	int token = 0;
	int a, count = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 31)//(locate)
			{
				for (a = 17; a <= 32; a++)
				{
					if (board[i - 2][j - 1] == a || board[i - 1][j - 2] == a || board[i + 2][j - 1] == a || board[i + 1][j - 2] == a ||
						board[i - 1][j + 2] == a || board[i - 2][j + 1] == a || board[i + 2][j + 1] == a || board[i + 1][j + 2] == a)
					{
						count++;
					}
				}
				for (a = 70; a <= 101; a++)
				{
					if (board[i - 2][j - 1] == a || board[i - 1][j - 2] == a || board[i + 2][j - 1] == a || board[i + 1][j - 2] == a ||
						board[i - 1][j + 2] == a || board[i - 2][j + 1] == a || board[i + 2][j + 1] == a || board[i + 1][j + 2] == a)
					{
						count++;
					}
				}
				if (i - 1 < 0)
					count++;
				if (j - 1 < 0)
					count++;
				if (i - 2 < 0)
					count++;
				if (j - 2 < 0)
					count++;
				if (i + 1 > 7)
					count++;
				if (j + 1 > 7)
					count++;
				if (i + 2 > 7)
					count++;
				if (j + 2 > 7)
					count++;
				if (count >= 8)//(grounded)
				{
					cout << "Unable to move" << endl;
					return;
				}
				if (d == 'q')
				{
					cout << "Major Up or Left (u,l) : ";
					char q;
					cin >> q;
					if (q == 'u')
					{
						if (i - 2 < 0 || j - 1 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						for (a = 17; a <= 32; a++)//(friend)
						{
							if (board[i - 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i - 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						if (board[i - 2][j - 1] == 13)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 1;
					}
					else if (q == 'l')
					{
						if (i - 1 < 0 || j - 2 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						for (a = 17; a <= 32; a++)//(friend)
						{
							if (board[i - 1][j - 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i - 1][j - 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						if (board[i - 1][j - 2] == 13)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 2;
					}
				}
				else if (d == 'w')
				{
					cout << "Major Up or Right (u,r) :";
					char q;
					cin >> q;
					if (q == 'u')
					{
						if (i - 2 < 0 || j + 1 > 7)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						for (a = 17; a <= 32; a++)//(freind)
						{
							if (board[i - 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i - 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						if (board[i - 2][j + 1] == 13)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 3;
					}
					else if (q == 'r')
					{
						if (i - 1 < 0 || j + 2 > 7)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						for (a = 17; a <= 32; a++)
						{
							if (board[i - 1][j + 2] == a)//(friend)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i - 1][j + 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						if (board[i - 1][j + 2] == 13)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 4;
					}
				}
				else if (d == 'a')
				{
					cout << "Major Down or Left (d,l) : ";
					char a;
					cin >> a;
					if (a == 'd')
					{
						if (i + 2 > 7 || j - 1 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						for (a = 17; a <= 32; a++)//(friend)
						{
							if (board[i + 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i + 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						if (board[i + 2][j - 1] == 13)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 5;
					}
					else if (a == 'l')
					{
						if (i + 1 > 7 || j - 2 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						for (a = 17; a <= 32; a++)
						{
							if (board[i + 1][j - 2] == a)//(friend)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i + 1][j - 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						if (board[i + 1][j - 2] == 13)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 6;
					}
				}
				else if (d == 's')
				{
					cout << "Major Down or Right (d,r) : ";
					char q;
					cin >> q;
					if (q == 'd')//(boundary2)
					{
						if (i + 2 > 7 || j + 1 > 7)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						for (a = 17; a <= 32; a++)//(friend)
						{
							if (board[i + 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i + 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						if (board[i + 2][j + 1] == 13)//takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 7;
					}
					else if (q == 'r')
					{
						if (i + 1 > 7 || j + 2 > 7)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						for (a = 17; a <= 32; a++)
						{
							if (board[i + 1][j + 2] == a)//(friend)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i + 1][j + 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnr();
							}
						}
						if (board[i + 1][j + 2] == 13)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnr();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 8;
					}
				}
				int r = 0;
				if (token == 1)
				{
					board[i - 2][j - 1] = 31;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 2][j - 1] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 2][j - 1] = r;
						board[i][j] = 31;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 2)
				{
					board[i - 1][j - 2] = 31;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 1][j - 2] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 1][j - 2] = r;
						board[i][j] = 31;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 3)
				{
					board[i - 2][j + 1] = 31;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 2][j + 1] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 2][j + 1] = r;
						board[i][j] = 31;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 4)
				{
					board[i - 1][j + 2] = 31;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 1][j + 2] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 1][j + 2] = r;
						board[i][j] = 31;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 5)
				{
					board[i + 2][j - 1] = 31;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + 2][j - 1] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 2][j - 1] = r;
						board[i][j] = 31;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 6)
				{
					board[i + 1][j - 2] = 31;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + 1][j - 2] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 1][j - 2] = r;
						board[i][j] = 31;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 7)//(checkCheck)
				{
					board[i + 2][j + 1] = 31;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)
					{
						if (board[i + 2][j + 1] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 2][j + 1] = r;
						board[i][j] = 31;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 8)//(checkCheck)
				{
					board[i + 1][j + 2] = 31;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)
					{
						if (board[i + 1][j + 2] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 1][j + 2] = r;
						board[i][j] = 31;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
			}
		}
	}
}
void Wnl()
{
	cout << "Left Knight" << endl;
	cout << "Direction (q,w,a,s) :";
	char d;
	cin >> d;
	if (d == 'p')
		return;
	int token = 0;
	int a, count = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 10)//(locate)
			{
				for (a = 1; a <= 16; a++)
				{
					if (board[i - 2][j - 1] == a || board[i - 1][j - 2] == a || board[i + 2][j - 1] == a || board[i + 1][j - 2] == a ||
						board[i - 1][j + 2] == a || board[i - 2][j + 1] == a || board[i + 2][j + 1] == a || board[i + 1][j + 2] == a)
					{
						count++;
					}
				}
				for (a = 33; a <= 64; a++)
				{
					if (board[i - 2][j - 1] == a || board[i - 1][j - 2] == a || board[i + 2][j - 1] == a || board[i + 1][j - 2] == a ||
						board[i - 1][j + 2] == a || board[i - 2][j + 1] == a || board[i + 2][j + 1] == a || board[i + 1][j + 2] == a)
					{
						count++;
					}
				}
				if (i - 1 < 0)
					count++;
				if (j - 1 < 0)
					count++;
				if (i - 2 < 0)
					count++;
				if (j - 2 < 0)
					count++;
				if (i + 1 > 7)
					count++;
				if (j + 1 > 7)
					count++;
				if (i + 2 > 7)
					count++;
				if (j + 2 > 7)
					count++;
				if (count >= 8)//(grounded)
				{
					cout << "Unable to move" << endl;
					return;
				}
				if (d == 'q')
				{
					cout << "Major Up or Left (u,l) : ";
					char q;
					cin >> q;
					if (q == 'u')
					{
						if (i - 2 < 0 || j - 1 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						for (a = 1; a <= 16; a++)//(friend)
						{
							if (board[i - 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i - 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						if (board[i - 2][j - 1] == 29)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 1;
					}
					else if (q == 'l')
					{
						if (i - 1 < 0 || j - 2 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						for (a = 1; a <= 16; a++)//(friend)
						{
							if (board[i - 1][j - 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i - 1][j - 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						if (board[i - 1][j - 2] == 29)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 2;
					}
				}
				else if (d == 'w')
				{
					cout << "Major Up or Right (u,r) :";
					char q;
					cin >> q;
					if (q == 'u')
					{
						if (i - 2 < 0 || j + 1 > 7)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						for (a = 1; a <= 16; a++)//(freind)
						{
							if (board[i - 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i - 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						if (board[i - 2][j + 1] == 29)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 3;
					}
					else if (q == 'r')
					{
						if (i - 1 < 0 || j + 2 > 7)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						for (a = 1; a <= 16; a++)
						{
							if (board[i - 1][j + 2] == a)//(friend)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i - 1][j + 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						if (board[i - 1][j + 2] == 29)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 4;
					}
				}
				else if (d == 'a')
				{
					cout << "Major Down or Left (d,l) : ";
					char a;
					cin >> a;
					if (a == 'd')
					{
						if (i + 2 > 7 || j - 1 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						for (a = 1; a <= 16; a++)//(friend)
						{
							if (board[i + 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i + 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						if (board[i + 2][j - 1] == 29)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 5;
					}
					else if (a == 'l')
					{
						if (i + 1 > 7 || j - 2 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						for (a = 1; a <= 16; a++)
						{
							if (board[i + 1][j - 2] == a)//(friend)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i + 1][j - 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						if (board[i + 1][j - 2] == 29)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 6;
					}
				}
				else if (d == 's')
				{
					cout << "Major Down or Right (d,r) : ";
					char q;
					cin >> q;
					if (q == 'd')//(boundary2)
					{
						if (i + 2 > 7 || j + 1 > 7)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						for (a = 1; a <= 16; a++)//(friend)
						{
							if (board[i + 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i + 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						if (board[i + 2][j + 1] == 29)//takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 7;
					}
					else if (q == 'r')
					{
						if (i + 1 > 7 || j + 2 > 7)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						for (a = 1; a <= 16; a++)
						{
							if (board[i + 1][j + 2] == a)//(friend)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						for (a = 33; a <= 64; a++)
						{
							if (board[i + 1][j + 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Wnl();
							}
						}
						if (board[i + 1][j + 2] == 29)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Wnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 8;
					}
				}
				int r = 0;
				if (token == 1)
				{
					board[i - 2][j - 1] = 10;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 2][j - 1] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 2][j - 1] = r;
						board[i][j] = 10;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 2)
				{
					board[i - 1][j - 2] = 10;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 1][j - 2] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 1][j - 2] = r;
						board[i][j] = 10;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 3)
				{
					board[i - 2][j + 1] = 10;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 2][j + 1] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 2][j + 1] = r;
						board[i][j] = 10;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 4)
				{
					board[i - 1][j + 2] = 10;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 1][j + 2] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 1][j + 2] = r;
						board[i][j] = 10;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 5)
				{
					board[i + 2][j - 1] = 10;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + 2][j - 1] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 2][j - 1] = r;
						board[i][j] = 10;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 6)
				{
					board[i + 1][j - 2] = 10;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + 1][j - 2] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 1][j - 2] = r;
						board[i][j] = 10;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 7)//(checkCheck)
				{
					board[i + 2][j + 1] = 10;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)
					{
						if (board[i + 2][j + 1] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 2][j + 1] = r;
						board[i][j] = 10;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 8)//(checkCheck)
				{
					board[i + 1][j + 2] = 10;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)
					{
						if (board[i + 1][j + 2] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 1][j + 2] = r;
						board[i][j] = 10;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
			}
		}
	}
}
void Bnl()
{
	cout << "Left Knight" << endl;
	cout << "Direction (q,w,a,s) :";
	char d;
	cin >> d;
	if (d == 'p')
		return;
	int token = 0;
	int a, count = 0;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 26)//(locate)
			{
				for (a = 17; a <= 32; a++)
				{
					if (board[i - 2][j - 1] == a || board[i - 1][j - 2] == a || board[i + 2][j - 1] == a || board[i + 1][j - 2] == a ||
						board[i - 1][j + 2] == a || board[i - 2][j + 1] == a || board[i + 2][j + 1] == a || board[i + 1][j + 2] == a)
					{
						count++;
					}
				}
				for (a = 70; a <= 101; a++)
				{
					if (board[i - 2][j - 1] == a || board[i - 1][j - 2] == a || board[i + 2][j - 1] == a || board[i + 1][j - 2] == a ||
						board[i - 1][j + 2] == a || board[i - 2][j + 1] == a || board[i + 2][j + 1] == a || board[i + 1][j + 2] == a)
					{
						count++;
					}
				}
				if (i - 1 < 0)
					count++;
				if (j - 1 < 0)
					count++;
				if (i - 2 < 0)
					count++;
				if (j - 2 < 0)
					count++;
				if (i + 1 > 7)
					count++;
				if (j + 1 > 7)
					count++;
				if (i + 2 > 7)
					count++;
				if (j + 2 > 7)
					count++;
				if (count >= 8)//(grounded)
				{
					cout << "Unable to move" << endl;
					return;
				}
				if (d == 'q')
				{
					cout << "Major Up or Left (u,l) : ";
					char q;
					cin >> q;
					if (q == 'u')
					{
						if (i - 2 < 0 || j - 1 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						for (a = 17; a <= 32; a++)//(friend)
						{
							if (board[i - 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i - 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						if (board[i - 2][j - 1] == 13)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 1;
					}
					else if (q == 'l')
					{
						if (i - 1 < 0 || j - 2 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						for (a = 17; a <= 32; a++)//(friend)
						{
							if (board[i - 1][j - 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i - 1][j - 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						if (board[i - 1][j - 2] == 13)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 2;
					}
				}
				else if (d == 'w')
				{
					cout << "Major Up or Right (u,r) :";
					char q;
					cin >> q;
					if (q == 'u')
					{
						if (i - 2 < 0 || j + 1 > 7)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						for (a = 17; a <= 32; a++)//(freind)
						{
							if (board[i - 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i - 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						if (board[i - 2][j + 1] == 13)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 3;
					}
					else if (q == 'r')
					{
						if (i - 1 < 0 || j + 2 > 7)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						for (a = 17; a <= 32; a++)
						{
							if (board[i - 1][j + 2] == a)//(friend)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i - 1][j + 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						if (board[i - 1][j + 2] == 13)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 4;
					}
				}
				else if (d == 'a')
				{
					cout << "Major Down or Left (d,l) : ";
					char a;
					cin >> a;
					if (a == 'd')
					{
						if (i + 2 > 7 || j - 1 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						for (a = 17; a <= 32; a++)//(friend)
						{
							if (board[i + 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i + 2][j - 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						if (board[i + 2][j - 1] == 13)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 5;
					}
					else if (a == 'l')
					{
						if (i + 1 > 7 || j - 2 < 0)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						for (a = 17; a <= 32; a++)
						{
							if (board[i + 1][j - 2] == a)//(friend)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i + 1][j - 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						if (board[i + 1][j - 2] == 13)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 6;
					}
				}
				else if (d == 's')
				{
					cout << "Major Down or Right (d,r) : ";
					char q;
					cin >> q;
					if (q == 'd')//(boundary2)
					{
						if (i + 2 > 7 || j + 1 > 7)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						for (a = 17; a <= 32; a++)//(friend)
						{
							if (board[i + 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i + 2][j + 1] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						if (board[i + 2][j + 1] == 13)//takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 7;
					}
					else if (q == 'r')
					{
						if (i + 1 > 7 || j + 2 > 7)//(boundary2)
						{
							cout << "Outside Map" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						for (a = 17; a <= 32; a++)
						{
							if (board[i + 1][j + 2] == a)//(friend)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						for (a = 70; a <= 101; a++)
						{
							if (board[i + 1][j + 2] == a)
							{
								cout << "Invalid move (Friendly piece)" << endl;
								i += 100;
								j += 100;
								Bnl();
							}
						}
						if (board[i + 1][j + 2] == 13)//(takeKing)
						{
							cout << "Cannot take the king!" << endl;
							i += 100;
							j += 100;
							Bnl();
						}
						if (token != 0)
							break;
						else if (token == 0)
							token = 8;
					}
				}
				int r = 0;
				if (token == 1)
				{
					board[i - 2][j - 1] = 26;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 2][j - 1] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 2][j - 1] = r;
						board[i][j] = 26;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 2)
				{
					board[i - 1][j - 2] = 26;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 1][j - 2] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 1][j - 2] = r;
						board[i][j] = 26;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 3)
				{
					board[i - 2][j + 1] = 26;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 2][j + 1] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 2][j + 1] = r;
						board[i][j] = 26;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 4)
				{
					board[i - 1][j + 2] = 26;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - 1][j + 2] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - 1][j + 2] = r;
						board[i][j] = 26;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 5)
				{
					board[i + 2][j - 1] = 26;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + 2][j - 1] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 2][j - 1] = r;
						board[i][j] = 26;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 6)
				{
					board[i + 1][j - 2] = 26;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + 1][j - 2] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 1][j - 2] = r;
						board[i][j] = 26;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 7)//(checkCheck)
				{
					board[i + 2][j + 1] = 26;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)
					{
						if (board[i + 2][j + 1] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 2][j + 1] = r;
						board[i][j] = 26;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 8)//(checkCheck)
				{
					board[i + 1][j + 2] = 26;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)
					{
						if (board[i + 1][j + 2] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + 1][j + 2] = r;
						board[i][j] = 26;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
			}
		}
	}
}
void Wbr()
{
	cout << "Right Bishop" << endl;
	int count1 = 0, count2 = 0, token = 0, q = 0, a = 0, count9 = 0;
	bool qb = false;
	cout << "Direction (q,w,a,s) :";
	char d;
	cin >> d;
	if (d == 'p')
		return;
	int n;
	cout << "How many units do you wish to travel: ";
	cin >> n;
	if (n != 1 && n != 2 && n != 3 && n != 4 && n != 5 && n != 6 && n != 7 && n != 8)//(boundary)
	{
		cout << "Invalid entry" << endl;
		return;
	}
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 14)//(locate)
			{
				if (i - 1 < 0)
				{
					count9 += 2;
				}
				if (i + 1 > 7)
				{
					count9 += 2;
				}
				if (j - 1 < 0)
				{
					count9 += 2;
				}
				if (j + 1 > 7)
				{
					count9 += 2;
				}
				for (a = 1; a <= 16; a++)
				{
					if (i > 0 && j > 0)
					{
						if (board[i - 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j < 7)
					{
						if (board[i + 1][j + 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j > 0)
					{
						if (board[i + 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i > 0 && j < 7)
					{
						if (board[i - 1][j + 1] == a)
						{
							count9++;
						}
					}
				}
				for (a = 33; a <= 64; a++)
				{
					if (i > 0 && j > 0)
					{
						if (board[i - 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j < 7)
					{
						if (board[i + 1][j + 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j > 0)
					{
						if (board[i + 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i > 0 && j < 7)
					{
						if (board[i - 1][j + 1] == a)
						{
							count9++;
						}
					}
				}
				if (count9 >= 4)//(grounded)
				{
					cout << "Cannot move" << endl;
					token = 99;
					i += 100;
					j += 100;
					return;
				}
				if (d == 'q')
				{
					w = j - 1;
					for (int q = i - 1; q > (i - n); q--, w--)
					{
						if (board[q][w] != 0)//(overlap)
						{
							cout << "Invalid Move.." << endl;
							i += 100;
							j += 100;
							token == 99;
							Wbr();
						}
					}
					if (i - n < 0 || j - n < 0)//(boundary2)
					{
						cout << "Outside Map" << endl;
						token = 99;
						i += 100;
						j += 100;
						Wbr();
					}
					for (a = 1; a <= 16; a++)
					{
						if (board[i - n][j - n] == a)//(friend)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							Wbr();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i - n][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							Wbr();
						}
					}
					if (board[i - n][j - n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						token = 99;
						i += 100;
						j += 100;
						Wbr();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 'q')
						token = 1;
				}
				if (d == 'w')
				{
					w = j + 1;
					for (int q = i - 1; q > (i - n); q--, w++)
					{
						if (count1 == count2)
						{
							if (board[q][w] != 0)
							{
								cout << "Invalid Move.." << endl;
								i += 100;
								j += 100;
								token == 99;
								Wbr();
							}
						}
					}
					if (i - n < 0 || j + n > 7)//(outsideMap2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						token = 99;
						Wbr();
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i - n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Wbr();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i - n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Wbr();
						}
					}
					if (board[i - n][j + n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						token = 99;
						Wbr();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 'w')
						token = 2;
				}
				if (d == 'a')
				{
					w = j - 1;
					for (int q = i + 1; q < (i + n); q++, w--)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							i += 100;
							j += 100;
							token == 99;
							Wbr();
						}
					}
					if (i + n > 7 || j - n < 0)//(outsideMap2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						token = 99;
						Wbr();
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i + n][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << a << i << j << endl;
							i += 100;
							j += 100;
							token = 99;
							Wbr();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i + n][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Wbr();
						}
					}
					if (board[i + n][j - n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						token = 99;
						Wbr();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 'a')
						token = 3;
				}
				if (d == 's')
				{
					w = j + 1;
					for (int q = i + 1; q < (i + n); q++, w++)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							i += 100;
							j += 100;
							token == 99;
							Wbr();
						}
					}
					if (i + n > 7 || j + n > 7)//(outsideMap2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						token = 99;
						Wbr();
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i + n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Wbr();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i + n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Wbr();
						}
					}
					if (board[i + n][j + n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						token = 99;
						Wbr();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 's')
						token = 4;
				}
				int r = 0;
				if (token == 1)
				{
					board[i - n][j - n] = 14;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//((checkCheck)
					{
						if (board[i - n][j - n] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - n][j - n] = r;
						board[i][j] = 14;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				if (token == 2)
				{
					board[i - n][j + n] = 14;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - n][j + n] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - n][j + n] = r;
						board[i][j] = 14;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				if (token == 3)
				{
					board[i + n][j - n] = 14;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + n][j - n] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j - n] = r;
						board[i][j] = 14;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				if (token == 4)
				{
					board[i + n][j + n] = 14;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + n][j + n] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j + n] = r;
						board[i][j] = 14;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
			}
		}
		if (token != 0)
			break;
	}
}
void Bbr()
{
	cout << "Right Bishop" << endl;
	int count1 = 0, count2 = 0, token = 0, q = 0, a = 0, count9 = 0;
	bool qb = false;
	cout << "Direction (q,w,a,s) :";
	char d;
	cin >> d;
	if (d == 'p')
		return;
	int n;
	cout << "How many units do you wish to travel: ";
	cin >> n;
	if (n != 1 && n != 2 && n != 3 && n != 4 && n != 5 && n != 6 && n != 7 && n != 8)//(boundary)
	{
		cout << "Invalid entry" << endl;
		return;
	}
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 30)//(locate)
			{
				if (i - 1 < 0)
				{
					count9 += 2;
				}
				if (i + 1 > 7)
				{
					count9 += 2;
				}
				if (j - 1 < 0)
				{
					count9 += 2;
				}
				if (j + 1 > 7)
				{
					count9 += 2;
				}
				for (a = 17; a <= 32; a++)
				{
					if (i > 0 && j > 0)
					{
						if (board[i - 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j < 7)
					{
						if (board[i + 1][j + 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j > 0)
					{
						if (board[i + 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i > 0 && j < 7)
					{
						if (board[i - 1][j + 1] == a)
						{
							count9++;
						}
					}
				}
				for (a = 70; a <= 101; a++)
				{
					if (i > 0 && j > 0)
					{
						if (board[i - 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j < 7)
					{
						if (board[i + 1][j + 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j > 0)
					{
						if (board[i + 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i > 0 && j < 7)
					{
						if (board[i - 1][j + 1] == a)
						{
							count9++;
						}
					}
				}
				if (count9 >= 4)//(grounded)
				{
					cout << "Cannot move" << endl;
					token = 99;
					i += 100;
					j += 100;
					return;
				}
				if (d == 'q')
				{
					w = j - 1;
					for (int q = i - 1; q > (i - n); q--, w--)
					{
						if (board[q][w] != 0)//(overlap)
						{
							cout << "Invalid Move.." << endl;
							i += 100;
							j += 100;
							token == 99;
							Bbr();
						}
					}
					if (i - n < 0 || j - n < 0)//(boundary2)
					{
						cout << "Outside Map" << endl;
						token = 99;
						i += 100;
						j += 100;
						Bbr();
					}
					for (a = 17; a <= 32; a++)
					{
						if (board[i - n][j - n] == a)//(friend)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							Bbr();
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i - n][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							Bbr();
						}
					}
					if (board[i - n][j - n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						token = 99;
						i += 100;
						j += 100;
						Bbr();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 'q')
						token = 1;
				}
				if (d == 'w')
				{
					w = j + 1;
					for (int q = i - 1; q > (i - n); q--, w++)
					{
						if (count1 == count2)
						{
							if (board[q][w] != 0)
							{
								cout << "Invalid Move.." << endl;
								i += 100;
								j += 100;
								token == 99;
								Bbr();
							}
						}
					}
					if (i - n < 0 || j + n > 7)//(outsideMap2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						token = 99;
						Bbr();
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i - n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Bbr();
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i - n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Bbr();
						}
					}
					if (board[i - n][j + n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						token = 99;
						Bbr();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 'w')
						token = 2;
				}
				if (d == 'a')
				{
					w = j - 1;
					for (int q = i + 1; q < (i + n); q++, w--)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							i += 100;
							j += 100;
							token == 99;
							Bbr();
						}
					}
					if (i + n > 7 || j - n < 0)//(outsideMap2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						token = 99;
						Bbr();
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i + n][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << a << i << j << endl;
							i += 100;
							j += 100;
							token = 99;
							Bbr();
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i + n][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Bbr();
						}
					}
					if (board[i + n][j - n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						token = 99;
						Bbr();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 'a')
						token = 3;
				}
				if (d == 's')
				{
					w = j + 1;
					for (int q = i + 1; q < (i + n); q++, w++)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							i += 100;
							j += 100;
							token == 99;
							Bbr();
						}
					}
					if (i + n > 7 || j + n > 7)//(outsideMap2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						token = 99;
						Bbr();
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i + n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Bbr();
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i + n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Bbr();
						}
					}
					if (board[i + n][j + n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						token = 99;
						Bbr();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 's')
						token = 4;
				}
				int r = 0;
				if (token == 1)
				{
					board[i - n][j - n] = 30;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//((checkCheck)
					{
						if (board[i - n][j - n] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - n][j - n] = r;
						board[i][j] = 30;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				if (token == 2)
				{
					board[i - n][j + n] = 30;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - n][j + n] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - n][j + n] = r;
						board[i][j] = 30;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				if (token == 3)
				{
					board[i + n][j - n] = 30;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + n][j - n] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j - n] = r;
						board[i][j] = 30;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				if (token == 4)
				{
					board[i + n][j + n] = 30;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + n][j + n] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j + n] = r;
						board[i][j] = 30;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
			}
		}
		if (token != 0)
			break;
	}
}
void Wbl()
{
	cout << "Left Bishop" << endl;
	int count1 = 0, count2 = 0, token = 0, q = 0, a = 0, count9 = 0;
	bool qb = false;
	cout << "Direction (q,w,a,s) :";
	char d;
	cin >> d;
	if (d == 'p')
		return;
	int n;
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 11)//(locate)
			{
				if (i - 1 < 0)
				{
					count9 += 2;
				}
				if (i + 1 > 7)
				{
					count9 += 2;
				}
				if (j - 1 < 0)
				{
					count9 += 2;
				}
				if (j + 1 > 7)
				{
					count9 += 2;
				}
				for (a = 1; a <= 16; a++)
				{
					if (i > 0 && j > 0)
					{
						if (board[i - 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j < 7)
					{
						if (board[i + 1][j + 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j > 0)
					{
						if (board[i + 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i > 0 && j < 7)
					{
						if (board[i - 1][j + 1] == a)
						{
							count9++;
						}
					}
				}
				for (a = 33; a <= 64; a++)
				{
					if (i > 0 && j > 0)
					{
						if (board[i - 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j < 7)
					{
						if (board[i + 1][j + 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j > 0)
					{
						if (board[i + 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i > 0 && j < 7)
					{
						if (board[i - 1][j + 1] == a)
						{
							count9++;
						}
					}
				}
				if (count9 >= 4)//(grounded)
				{
					cout << "Cannot move" << endl;
					token = 99;
					i += 100;
					j += 100;
					return;
				}
				cout << "How many units do you wish to travel: ";
				cin >> n;
				if (n != 1 && n != 2 && n != 3 && n != 4 && n != 5 && n != 6 && n != 7 && n != 8)//(boundary)
				{
					cout << "Invalid entry" << endl;
					return;
				}
				if (d == 'q')
				{
					w = j - 1;
					for (int q = i - 1; q > (i - n); q--, w--)
					{
						if (board[q][w] != 0)//(overlap)
						{
							cout << "Invalid Move.." << endl;
							i += 100;
							j += 100;
							token == 99;
							Wbl();
						}
					}
					if (i - n < 0 || j - n < 0)//(boundary2)
					{
						cout << "Outside Map" << endl;
						token = 99;
						i += 100;
						j += 100;
						Wbl();
					}
					for (a = 1; a <= 16; a++)
					{
						if (board[i - n][j - n] == a)//(friend)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							Wbl();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i - n][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							Wbl();
						}
					}
					if (board[i - n][j - n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						token = 99;
						i += 100;
						j += 100;
						Wbl();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 'q')
						token = 1;
				}
				if (d == 'w')
				{
					w = j + 1;
					for (int q = i - 1; q > (i - n); q--, w++)
					{
						if (count1 == count2)
						{
							if (board[q][w] != 0)
							{
								cout << "Invalid Move.." << endl;
								i += 100;
								j += 100;
								token == 99;
								Wbl();
							}
						}
					}
					if (i - n < 0 || j + n > 7)//(outsideMap2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						token = 99;
						Wbl();
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i - n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Wbl();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i - n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Wbl();
						}
					}
					if (board[i - n][j + n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						token = 99;
						Wbl();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 'w')
						token = 2;
				}
				if (d == 'a')
				{
					w = j - 1;
					for (int q = i + 1; q < (i + n); q++, w--)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							i += 100;
							j += 100;
							token == 99;
							Wbl();
						}
					}
					if (i + n > 7 || j - n < 0)//(outsideMap2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						token = 99;
						Wbl();
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i + n][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << a << i << j << endl;
							i += 100;
							j += 100;
							token = 99;
							Wbl();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i + n][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Wbl();
						}
					}
					if (board[i + n][j - n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						token = 99;
						Wbl();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 'a')
						token = 3;
				}
				if (d == 's')
				{
					w = j + 1;
					for (int q = i + 1; q < (i + n); q++, w++)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							i += 100;
							j += 100;
							token == 99;
							Wbl();
						}
					}
					if (i + n > 7 || j + n > 7)//(outsideMap2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						token = 99;
						Wbl();
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i + n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Wbl();
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i + n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Wbl();
						}
					}
					if (board[i + n][j + n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						token = 99;
						Wbl();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 's')
						token = 4;
				}
				int r = 0;
				if (token == 1)
				{
					board[i - n][j - n] = 11;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//((checkCheck)
					{
						if (board[i - n][j - n] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - n][j - n] = r;
						board[i][j] = 11;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				if (token == 2)
				{
					board[i - n][j + n] = 11;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - n][j + n] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - n][j + n] = r;
						board[i][j] = 11;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				if (token == 3)
				{
					board[i + n][j - n] = 11;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + n][j - n] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j - n] = r;
						board[i][j] = 11;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				if (token == 4)
				{
					board[i + n][j + n] = 11;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + n][j + n] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j + n] = r;
						board[i][j] = 11;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
			}
		}
		if (token != 0)
			break;
	}
}
void Bbl()
{
	cout << "Left Bishop" << endl;
	int count1 = 0, count2 = 0, token = 0, q = 0, a = 0, count9 = 0;
	bool qb = false;
	cout << "Direction (q,w,a,s) :";
	char d;
	cin >> d;
	if (d == 'p')
		return;
	int n;
	cout << "How many units do you wish to travel: ";
	cin >> n;
	if (n != 1 && n != 2 && n != 3 && n != 4 && n != 5 && n != 6 && n != 7 && n != 8)//(boundary)
	{
		cout << "Invalid entry" << endl;
		return;
	}
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			if (board[i][j] == 27)//(locate)
			{
				if (i - 1 < 0)
				{
					count9 += 2;
				}
				if (i + 1 > 7)
				{
					count9 += 2;
				}
				if (j - 1 < 0)
				{
					count9 += 2;
				}
				if (j + 1 > 7)
				{
					count9 += 2;
				}
				for (a = 17; a <= 32; a++)
				{
					if (i > 0 && j > 0)
					{
						if (board[i - 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j < 7)
					{
						if (board[i + 1][j + 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j > 0)
					{
						if (board[i + 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i > 0 && j < 7)
					{
						if (board[i - 1][j + 1] == a)
						{
							count9++;
						}
					}
				}
				for (a = 70; a <= 101; a++)
				{
					if (i > 0 && j > 0)
					{
						if (board[i - 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j < 7)
					{
						if (board[i + 1][j + 1] == a)
						{
							count9++;
						}
					}
					if (i < 7 && j > 0)
					{
						if (board[i + 1][j - 1] == a)
						{
							count9++;
						}
					}
					if (i > 0 && j < 7)
					{
						if (board[i - 1][j + 1] == a)
						{
							count9++;
						}
					}
				}
				if (count9 >= 4)//(grounded)
				{
					cout << "Cannot move" << endl;
					token = 99;
					i += 100;
					j += 100;
					return;
				}
				if (d == 'q')
				{
					w = j - 1;
					for (int q = i - 1; q > (i - n); q--, w--)
					{
						if (board[q][w] != 0)//(overlap)
						{
							cout << "Invalid Move.." << endl;
							i += 100;
							j += 100;
							token == 99;
							Bbl();
						}
					}
					if (i - n < 0 || j - n < 0)//(boundary2)
					{
						cout << "Outside Map" << endl;
						token = 99;
						i += 100;
						j += 100;
						Bbl();
					}
					for (a = 17; a <= 32; a++)
					{
						if (board[i - n][j - n] == a)//(friend)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							Bbl();
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i - n][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							Bbl();
						}
					}
					if (board[i - n][j - n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						token = 99;
						i += 100;
						j += 100;
						Bbl();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 'q')
						token = 1;
				}
				if (d == 'w')
				{
					w = j + 1;
					for (int q = i - 1; q > (i - n); q--, w++)
					{
						if (count1 == count2)
						{
							if (board[q][w] != 0)
							{
								cout << "Invalid Move.." << endl;
								i += 100;
								j += 100;
								token == 99;
								Bbl();
							}
						}
					}
					if (i - n < 0 || j + n > 7)//(outsideMap2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						token = 99;
						Bbl();
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i - n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Bbl();
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i - n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Bbl();
						}
					}
					if (board[i - n][j + n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						token = 99;
						Bbl();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 'w')
						token = 2;
				}
				if (d == 'a')
				{
					w = j - 1;
					for (int q = i + 1; q < (i + n); q++, w--)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							i += 100;
							j += 100;
							token == 99;
							Bbl();
						}
					}
					if (i + n > 7 || j - n < 0)//(outsideMap2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						token = 99;
						Bbl();
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i + n][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << a << i << j << endl;
							i += 100;
							j += 100;
							token = 99;
							Bbl();
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i + n][j - n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Bbl();
						}
					}
					if (board[i + n][j - n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						token = 99;
						Bbl();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 'a')
						token = 3;
				}
				if (d == 's')
				{
					w = j + 1;
					for (int q = i + 1; q < (i + n); q++, w++)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							i += 100;
							j += 100;
							token == 99;
							Bbl();
						}
					}
					if (i + n > 7 || j + n > 7)//(outsideMap2)
					{
						cout << "Outside Map" << endl;
						i += 100;
						j += 100;
						token = 99;
						Bbl();
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i + n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Bbl();
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i + n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							i += 100;
							j += 100;
							token = 99;
							Bbl();
						}
					}
					if (board[i + n][j + n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						token = 99;
						Bbl();
					}
					if (token == 99)
						break;
					else if (token != 99 && d == 's')
						token = 4;
				}
				int r = 0;
				if (token == 1)
				{
					board[i - n][j - n] = 27;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//((checkCheck)
					{
						if (board[i - n][j - n] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - n][j - n] = r;
						board[i][j] = 27;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				if (token == 2)
				{
					board[i - n][j + n] = 27;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - n][j + n] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - n][j + n] = r;
						board[i][j] = 27;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				if (token == 3)
				{
					board[i + n][j - n] = 27;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + n][j - n] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j - n] = r;
						board[i][j] = 27;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				if (token == 4)
				{
					board[i + n][j + n] = 27;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + n][j + n] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j + n] = r;
						board[i][j] = 27;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
			}
		}
		if (token != 0)
			break;
	}
}
void WQ()
{
	bool qq = false;
	wCheck = false;
	char d = 0;
	int n = 0, q = 0, a = 0, i = 0, j = 0, z = 0, f = 0;
	int token = 0;
	int r = 0;
	cout << "Queen:" << endl;
	int count = 0;
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			if (board[i][j] == 12)//(locate)
			{
				if (i - 1 < 0)
				{
					count += 3;
				}
				if (i + 1 > 7)
				{
					count += 3;
				}
				if (j - 1 < 0)
				{
					count += 3;
				}
				if (j + 1 > 7)
				{
					count += 3;
				}
				for (a = 1; a <= 16; a++)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
							count++;
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
							count++;
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
							count++;
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
							count++;
					}
					if (i > 0 && j > 0)
					{
						if (board[i - 1][j - 1] == a)
							count++;
					}
					if (i < 7 && j < 7)
					{
						if (board[i + 1][j + 1] == a)
							count++;
					}
					if (i < 7 && j > 0)
					{
						if (board[i + 1][j - 1] == a)
							count++;
					}
					if (i > 0 && j < 7)
					{
						if (board[i - 1][j + 1] == a)
							count++;
					}
				}
				for (a = 33; a <= 64; a++)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
							count++;
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
							count++;
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
							count++;
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
							count++;
					}
					if (i > 0 && j > 0)
					{
						if (board[i - 1][j - 1] == a)
							count++;
					}
					if (i < 7 && j < 7)
					{
						if (board[i + 1][j + 1] == a)
							count++;
					}
					if (i < 7 && j > 0)
					{
						if (board[i + 1][j - 1] == a)
							count++;
					}
					if (i > 0 && j < 7)
					{
						if (board[i - 1][j + 1] == a)
							count++;
					}
				}
				if (count >= 8)//(grounded)
				{
					cout << "Cannot move" << endl;
					i += 100;
					j += 100;
					return;
				}
				cout << "Direction (q,w,e,a,d,z,x,c) :";
				cin >> d;
				if (d == 'p')
					return;
				if (d != 'w' && d != 'a' && d != 'd' && d != 'q' && d != 'e' && d != 'z' && d != 'x' && d != 'c')
				{
					cout << "Error" << endl;
					i += 100;
					j += 100;
					WQ();
					break;
				}
				cout << "How many spaces do you wish to move? :";
				cin >> n;
				if (n == 0 || n != 1 && n != 2 && n != 3 && n != 4 && n != 5 && n != 6 && n != 7) //(boundary)
				{
					cout << "Must move (within boardspace)" << endl;
					qq = true;
					i += 100;
					j += 100;
					WQ();
					break;
				}
				if (d == 'w')
				{
					cout << "Up" << endl;
					if (i - n < 0)//(boundary2)
					{
						cout << "Outside Map" << endl;
						qq = true;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					for (q = i - 1; q >= (i - n + 1); q--)//(overlap)
					{
						if (board[q][j] != 0)
						{
							cout << "Invalid Move" << endl;
							q -= 100;
							qq = true;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i - n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i - n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					if (board[i - n][j] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					if (qq == true)
						token = 0;
					else
						token = 1;
				}
				else if (d == 'x')
				{
					cout << "Down:" << endl;
					if (i + n > 7)//(boundary2)
					{
						cout << "Outside Map" << endl;
						qq = true;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					for (q = i + 1; q <= (i + n - 1); q++)//(overlap)
					{
						if (board[q][j] != 0)
						{
							cout << "Invalid Move" << endl;
							q += 100;
							qq = true;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i + n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i + n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					if (board[i + n][j] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						qq = true;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					if (qq == true)
						token = 0;
					else
						token = 2;
				}
				else if (d == 'a')
				{
					cout << "Left:" << endl;
					if (j - n < 0)//(boundary2)
					{
						cout << "Outside Map" << endl;
						qq = true;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					for (q = j - 1; q >= (j - n + 1); q--)//(overlap)
					{
						if (board[i][q] != 0)
						{
							cout << "Invalid Move" << endl;
							q -= 100;
							qq = true;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i][j - n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i][j - n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					if (board[i][j - n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						qq = true;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					if (qq == true)
					{
						cout << "true" << endl;
						token = 0;
					}
					else
						token = 3;
				}
				else if (d == 'd')
				{
					cout << "Right:" << endl;
					if (j + n > 7)//(boundary)
					{
						cout << "Outside Map" << endl;
						qq = true;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					for (q = j + 1; q <= (j + n - 1); q++)//(overlap)
					{
						if (board[i][q] != 0)
						{
							cout << "Invalid Move" << endl;
							q += 100;
							qq = true;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i][j + n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i][j + n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					if (board[i][j + n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						qq = true;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					if (qq == true)
						token = 0;
					else
						token = 4;
				}
				if (d == 'q')
				{
					w = j - 1;
					for (int q = i - 1; q > (i - n); q--, w--)//(overlap)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							token = 99;
							i += 100;
							j += 100;
							token == 99;
							WQ();
							break;
						}
					}
					if (i - n < 0 || j - n < 0)//(boundary2)
					{
						cout << "Outside Map" << endl;
						token = 99;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i - n][j - n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i - n][j - n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					if (board[i - n][j - n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						token = 99;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					if (token == 99)
						break;
					else
						token = 5;
				}
				if (d == 'e')
				{
					w = j + 1;
					for (int q = i - 1; q > (i - n); q--, w++)//(overlap)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							token = 99;
							i += 100;
							j += 100;
							token == 99;
							WQ();
							break;
						}
					}
					if (i - n < 0 || j + n > 7)//(boundary2)
					{
						cout << "Outside Map" << endl;
						token = 99;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i - n][j + n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i - n][j + n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					if (board[i - n][j + n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						token = 99;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					if (token == 99)
						break;
					else
						token = 6;
				}
				if (d == 'z')
				{
					w = j - 1;
					for (int q = i + 1; q < (i + n); q++, w--)//(overlap)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							token = 99;
							i += 100;
							j += 100;
							token == 99;
							WQ();
							break;
						}
					}
					if (i + n > 7 || j - n < 0)//(boundary)
					{
						cout << "Outside Map" << endl;
						token = 99;
						d = 0;
						n = 0;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i + n][j - n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i + n][j - n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					if (board[i + n][j - n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						token = 99;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					if (token == 99)
						break;
					else
						token = 7;
				}
				if (d == 'c')
				{
					w = j + 1;
					for (int q = i + 1; q < (i + n); q++, w++)//(overlap)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							i += 100;
							j += 100;
							token == 99;
							WQ();
							break;
						}
					}
					if (i + n > 7 || j + n > 7)//(boundary2)
					{
						cout << "Outside Map" << endl;
						token = 99;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					for (a = 1; a <= 16; a++)//(friend)
					{
						if (board[i + n][j + n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					for (a = 33; a <= 64; a++)
					{
						if (board[i + n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							WQ();
							break;
						}
					}
					if (board[i + n][j + n] == 29)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						token = 99;
						i += 100;
						j += 100;
						WQ();
						break;
					}
					if (token == 99)
						break;
					else
						token = 8;
				}
				if (token == 1 && qq == false)
				{
					board[i - n][j] = 12;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - n][j] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - n][j] = r;
						board[i][j] = 12;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 2 && qq == false)
				{
					board[i + n][j] = 12;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + n][j] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j] = r;
						board[i][j] = 12;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 3 && qq == false)
				{
					board[i][j - n] = 12;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i][j - n] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i][j - n] = r;
						board[i][j] = 12;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 4 && qq == false)
				{
					board[i][j + n] = 12;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i][j + n] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i][j + n] = r;
						board[i][j] = 12;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 5)
				{
					board[i - n][j - n] = 12;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - n][j - n] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j + n] = r;
						board[i][j] = 12;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 6)
				{
					board[i - n][j + n] = 12;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - n][j + n] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - n][j + n] = r;
						board[i][j] = 12;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 7)
				{
					board[i + n][j - n] = 12;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + n][j - n] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j - n] = r;
						board[i][j] = 12;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
				else if (token == 8)
				{
					board[i + n][j + n] = 12;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + n][j + n] == w)
						{
							r = w;
							break;
						}
					}
					WhiteCheck();
					if (wCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j + n] = r;
						board[i][j] = 12;
						return;
					}
					i += 100;
					j += 100;
					contw = true;
				}
			}
		}
		if (token != 0)
			break;
	}
}
void BQ()
{
	bool qq = false;
	bCheck = false;
	char d = 0;
	int n = 0, q = 0, a = 0, i = 0, j = 0, z = 0, f = 0;
	int token = 0;
	int r = 0;
	cout << "Queen:" << endl;
	int count = 0;
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			if (board[i][j] == 28)//(locate)
			{
				if (i - 1 < 0)
				{
					count += 3;
				}
				if (i + 1 > 7)
				{
					count += 3;
				}
				if (j - 1 < 0)
				{
					count += 3;
				}
				if (j + 1 > 7)
				{
					count += 3;
				}
				for (a = 1; a <= 16; a++)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
							count++;
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
							count++;
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
							count++;
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
							count++;
					}
					if (i > 0 && j > 0)
					{
						if (board[i - 1][j - 1] == a)
							count++;
					}
					if (i < 7 && j < 7)
					{
						if (board[i + 1][j + 1] == a)
							count++;
					}
					if (i < 7 && j > 0)
					{
						if (board[i + 1][j - 1] == a)
							count++;
					}
					if (i > 0 && j < 7)
					{
						if (board[i - 1][j + 1] == a)
							count++;
					}
				}
				for (a = 33; a <= 64; a++)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
							count++;
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
							count++;
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
							count++;
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
							count++;
					}
					if (i > 0 && j > 0)
					{
						if (board[i - 1][j - 1] == a)
							count++;
					}
					if (i < 7 && j < 7)
					{
						if (board[i + 1][j + 1] == a)
							count++;
					}
					if (i < 7 && j > 0)
					{
						if (board[i + 1][j - 1] == a)
							count++;
					}
					if (i > 0 && j < 7)
					{
						if (board[i - 1][j + 1] == a)
							count++;
					}
				}
				if (count >= 8)//(grounded)
				{
					cout << "Cannot move" << endl;
					i += 100;
					j += 100;
					return;
				}
				cout << "Direction (q,w,e,a,d,z,x,c) :";
				cin >> d;
				if (d == 'p')
					return;
				if (d != 'w' && d != 'a' && d != 'd' && d != 'q' && d != 'e' && d != 'z' && d != 'x' && d != 'c')
				{
					cout << "Error" << endl;
					i += 100;
					j += 100;
					BQ();
					break;
				}
				cout << "How many spaces do you wish to move? :";
				cin >> n;
				if (n == 0 || n != 1 && n != 2 && n != 3 && n != 4 && n != 5 && n != 6 && n != 7) //(boundary)
				{
					cout << "Must move (within boardspace)" << endl;
					qq = true;
					i += 100;
					j += 100;
					BQ();
					break;
				}
				if (d == 'w')
				{
					cout << "Up" << endl;
					if (i - n < 0)//(boundary2)
					{
						cout << "Outside Map" << endl;
						qq = true;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					for (q = i - 1; q >= (i - n + 1); q--)//(overlap)
					{
						if (board[q][j] != 0)
						{
							cout << "Invalid Move" << endl;
							q -= 100;
							qq = true;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i - n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i - n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					if (board[i - n][j] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					if (qq == true)
						token = 0;
					else
						token = 1;
				}
				else if (d == 'x')
				{
					cout << "Down:" << endl;
					if (i + n > 7)//(boundary2)
					{
						cout << "Outside Map" << endl;
						qq = true;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					for (q = i + 1; q <= (i + n - 1); q++)//(overlap)
					{
						if (board[q][j] != 0)
						{
							cout << "Invalid Move" << endl;
							q += 100;
							qq = true;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i + n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i + n][j] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					if (board[i + n][j] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						qq = true;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					if (qq == true)
						token = 0;
					else
						token = 2;
				}
				else if (d == 'a')
				{
					cout << "Left:" << endl;
					if (j - n < 0)//(boundary2)
					{
						cout << "Outside Map" << endl;
						qq = true;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					for (q = j - 1; q >= (j - n + 1); q--)//(overlap)
					{
						if (board[i][q] != 0)
						{
							cout << "Invalid Move" << endl;
							q -= 100;
							qq = true;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i][j - n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i][j - n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					if (board[i][j - n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						qq = true;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					if (qq == true)
					{
						cout << "true" << endl;
						token = 0;
					}
					else
						token = 3;
				}
				else if (d == 'd')
				{
					cout << "Right:" << endl;
					if (j + n > 7)//(boundary)
					{
						cout << "Outside Map" << endl;
						qq = true;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					for (q = j + 1; q <= (j + n - 1); q++)//(overlap)
					{
						if (board[i][q] != 0)
						{
							cout << "Invalid Move" << endl;
							q += 100;
							qq = true;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i][j + n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i][j + n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							qq = true;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					if (board[i][j + n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						qq = true;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					if (qq == true)
						token = 0;
					else
						token = 4;
				}
				if (d == 'q')
				{
					w = j - 1;
					for (int q = i - 1; q > (i - n); q--, w--)//(overlap)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							token = 99;
							i += 100;
							j += 100;
							token == 99;
							BQ();
							break;
						}
					}
					if (i - n < 0 || j - n < 0)//(boundary2)
					{
						cout << "Outside Map" << endl;
						token = 99;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i - n][j - n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i - n][j - n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					if (board[i - n][j - n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						token = 99;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					if (token == 99)
						break;
					else
						token = 5;
				}
				if (d == 'e')
				{
					w = j + 1;
					for (int q = i - 1; q > (i - n); q--, w++)//(overlap)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							token = 99;
							i += 100;
							j += 100;
							token == 99;
							BQ();
							break;
						}
					}
					if (i - n < 0 || j + n > 7)//(boundary2)
					{
						cout << "Outside Map" << endl;
						token = 99;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i - n][j + n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i - n][j + n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					if (board[i - n][j + n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						token = 99;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					if (token == 99)
						break;
					else
						token = 6;
				}
				if (d == 'z')
				{
					w = j - 1;
					for (int q = i + 1; q < (i + n); q++, w--)//(overlap)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							token = 99;
							i += 100;
							j += 100;
							token == 99;
							BQ();
							break;
						}
					}
					if (i + n > 7 || j - n < 0)//(boundary)
					{
						cout << "Outside Map" << endl;
						token = 99;
						d = 0;
						n = 0;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i + n][j - n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i + n][j - n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					if (board[i + n][j - n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						token = 99;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					if (token == 99)
						break;
					else
						token = 7;
				}
				if (d == 'c')
				{
					w = j + 1;
					for (int q = i + 1; q < (i + n); q++, w++)//(overlap)
					{
						if (board[q][w] != 0)
						{
							cout << "Invalid Move.." << endl;
							i += 100;
							j += 100;
							token == 99;
							BQ();
							break;
						}
					}
					if (i + n > 7 || j + n > 7)//(boundary2)
					{
						cout << "Outside Map" << endl;
						token = 99;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					for (a = 17; a <= 32; a++)//(friend)
					{
						if (board[i + n][j + n] == a)
						{
							cout << "Invalid move (Freindly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					for (a = 70; a <= 101; a++)
					{
						if (board[i + n][j + n] == a)
						{
							cout << "Invalid move (Friendly piece)" << endl;
							token = 99;
							i += 100;
							j += 100;
							BQ();
							break;
						}
					}
					if (board[i + n][j + n] == 13)//(takeKing)
					{
						cout << "Cannot take the king!" << endl;
						token = 99;
						i += 100;
						j += 100;
						BQ();
						break;
					}
					if (token == 99)
						break;
					else
						token = 8;
				}
				if (token == 1 && qq == false)
				{
					board[i - n][j] = 28;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - n][j] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - n][j] = r;
						board[i][j] = 28;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 2 && qq == false)
				{
					board[i + n][j] = 28;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + n][j] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j] = r;
						board[i][j] = 28;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 3 && qq == false)
				{
					board[i][j - n] = 28;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i][j - n] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i][j - n] = r;
						board[i][j] = 28;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 4 && qq == false)
				{
					board[i][j + n] = 28;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i][j + n] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i][j + n] = r;
						board[i][j] = 28;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 5)
				{
					board[i - n][j - n] = 28;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - n][j - n] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j + n] = r;
						board[i][j] = 28;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 6)
				{
					board[i - n][j + n] = 28;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i - n][j + n] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i - n][j + n] = r;
						board[i][j] = 28;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 7)
				{
					board[i + n][j - n] = 28;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + n][j - n] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j - n] = r;
						board[i][j] = 28;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
				else if (token == 8)
				{
					board[i + n][j + n] = 28;
					board[i][j] = 0;
					for (int w = 0; w < 102; w++)//(checkCheck)
					{
						if (board[i + n][j + n] == w)
						{
							r = w;
							break;
						}
					}
					BlackCheck();
					if (bCheck == true)
					{
						cout << "Cannot endanger the king!" << endl;
						board[i + n][j + n] = r;
						board[i][j] = 28;
						return;
					}
					i += 100;
					j += 100;
					contb = true;
				}
			}
		}
		if (token != 0)
			break;
	}
}
void WK()
{
	bool qk = false;
	char d = 0;
	int q = 0, a = 0, i = 0, j = 0, z = 0, f = 0, r = 0;
	int up = 0, upl = 0, upr = 0, dn = 0, dl = 0, dr = 0, lt = 0, rt = 0;
	int token = 0;
	cout << "KING:" << endl;
	int count = 0;
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			if (board[i][j] == 13)//(locate)
			{
				//Following if statements disallow the player from moving the king in illegal places, using ints that are assigned to value 1 for every illegal direction
				if (i - 1 < 0)//(boundary)
				{
					count += 3;
					up = 1;
					upl = 1;
					upr = 1;
				}
				if (i + 1 > 7)
				{
					count += 3;
					dn = 1;
					dr = 1;
					dl = 1;
				}
				if (j - 1 < 0)
				{
					count += 3;
					upl = 1;
					lt = 1;
					dl = 1;
				}
				if (j + 1 > 7)
				{
					count += 3;
					upr = 1;
					rt = 1;
					dr = 1;
				}
				for (a = 1; a <= 16; a++)//(friend)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
						{
							count++;
							up = 1;
						}
						if (board[i - 1][j - 1] == a)
						{
							count++;
							upl = 1;
						}
						if (board[i - 1][j + 1] == a)
						{
							count++;
							upr = 1;
						}
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
						{
							count++;
							dn = 1;
						}
						if (board[i + 1][j - 1] == a)
						{
							count++;
							dl = 1;
						}
						if (board[i + 1][j + 1] == a)
						{
							count++;
							dr = 1;
						}
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
						{
							count++;
							lt = 1;
						}
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
						{
							count++;
							rt = 1;
						}
					}
				}
				for (a = 33; a <= 64; a++)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
						{
							count++;
							up = 1;
						}
						if (board[i - 1][j - 1] == a)
						{
							count++;
							upl = 1;
						}
						if (board[i - 1][j + 1] == a)
						{
							count++;
							upr = 1;
						}
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
						{
							count++;
							dn = 1;
						}
						if (board[i + 1][j - 1] == a)
						{
							count++;
							dl = 1;
						}
						if (board[i + 1][j + 1] == a)
						{
							count++;
							dr = 1;
						}
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
						{
							count++;
							lt = 1;
						}
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
						{
							count++;
							rt = 1;
						}
					}
				}
				if (count >= 8)//(grounded)
				{
					cout << "Cannot move" << endl;
					i += 100;
					j += 100;
					return;
				}
				cout << "Direction (q,w,e,a,s,d,z,x,c) :";
				cin >> d;
				if (d == 'p')
					return;
				if (d != 'w' && d != 'a' && d != 'x' && d != 'd' && d != 'q' && d != 'e' && d != 'z' && d != 'c')
				{
					cout << "Error" << endl;
					WK();
				}
				if (d == 'w')
				{
					if (up == 1)
					{
						cout << "Invalid direction" << endl;
						i += 100;
						j += 100;
						WK();
					}
					else
					{
						board[i - 1][j] = 13;
						board[i][j] = 0;
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i - 1][j] == w)
							{
								r = w;
								break;
							}
						}
						board[i - 1][j] = 13;
						board[i][j] = 0;
						WhiteCheck();
						if (wCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i - 1][j] = r;
							board[i][j] = 13;
							return;
						}
						i += 100;
						j += 100;
						contw = true;
						cout << "Up" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
				else if (d == 'x')
				{
					if (dn == 1)
					{
						cout << "Invalid direction" << endl;
						i += 100;
						j += 100;
						WK();
					}
					else if (dn == 0)
					{
						board[i + 1][j] = 13;
						board[i][j] = 0;
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i + 1][j] == w)
							{
								r = w;
								break;
							}
						}
						board[i + 1][j] = 13;
						board[i][j] = 0;
						WhiteCheck();
						if (wCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i + 1][j] = r;
							board[i][j] = 13;
							return;
						}
						i += 100;
						j += 100;
						contw = true;
						cout << "Down" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
				else if (d == 'a')
				{
					if (lt == 1)
					{
						cout << "Invalid direction" << endl;
						i += 100;
						j += 100;
						WK();
					}
					else if (lt == 0)
					{
						board[i][j - 1] = 13;
						board[i][j] = 0;
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i][j - 1] == w)
							{
								r = w;
								break;
							}
						}
						board[i][j - 1] = 13;
						board[i][j] = 0;
						WhiteCheck();
						if (wCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i][j - 1] = r;
							board[i][j] = 13;
							return;
						}
						i += 100;
						j += 100;
						contw = true;
						cout << "Left" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
				else if (d == 'd')
				{
					if (dn == 1)
					{
						cout << "Invalid direction" << endl;
						i += 100;
						j += 100;
						WK();
					}
					else if (dn == 0)
					{
						board[i][j + 1] = 13;
						board[i][j] = 0;
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i][j + 1] == w)
							{
								r = w;
								break;
							}
						}
						board[i][j + 1] = 13;
						board[i][j] = 0;
						WhiteCheck();
						if (wCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i][j + 1] = r;
							board[i][j] = 13;
							return;
						}
						i += 100;
						j += 100;
						contw = true;
						cout << "Right" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
				else if (d == 'q')
				{
					if (upl == 1)
					{
						cout << "Invalid direction" << endl;
						f = 5;
						i += 100;
						j += 100;
						WK();
					}
					else if (upl == 0)
					{
						board[i - 1][j - 1] = 13;
						board[i][j] = 0;
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i - 1][j - 1] == w)
							{
								r = w;
								break;
							}
						}
						board[i - 1][j - 1] = 13;
						board[i][j] = 0;
						WhiteCheck();
						if (wCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i - 1][j - 1] = r;
							board[i][j] = 13;
							return;
						}
						i += 100;
						j += 100;
						contw = true;
						cout << "UpLeft" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
				else if (d == 'e')
				{
					if (upr == 1)
					{
						cout << "Invalid direction" << endl;
						i += 100;
						j += 100;
						WK();
					}
					else if (upr == 0)
					{
						board[i - 1][j + 1] = 13;
						board[i][j] = 0;
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i - 1][j + 1] == w)
							{
								r = w;
								break;
							}
						}
						board[i - 1][j + 1] = 13;
						board[i][j] = 0;
						WhiteCheck();
						if (wCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i - 1][j + 1] = r;
							board[i][j] = 13;
							return;
						}
						i += 100;
						j += 100;
						contw = true;
						cout << "UpRight" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
				else if (d == 'z')
				{
					if (dl == 1)
					{
						cout << "Invalid direction" << endl;
						i += 100;
						j += 100;
						WK();
					}
					else if (dl == 0)
					{
						board[i + 1][j - 1] = 13;
						board[i][j] = 0;
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i + 1][j - 1] == w)
							{
								r = w;
								break;
							}
						}
						board[i + 1][j - 1] = 13;
						board[i][j] = 0;
						WhiteCheck();
						if (wCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i + 1][j - 1] = r;
							board[i][j] = 13;
							return;
						}
						i += 100;
						j += 100;
						contw = true;
						cout << "DownLeft" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
				else if (d == 'c')
				{
					if (dr == 1)
					{
						cout << "Invalid direction" << endl;
						i += 100;
						j += 100;
						WK();
					}
					else if (dr == 0)
					{
						board[i + 1][j + 1] = 13;
						board[i][j] = 0;
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i + 1][j + 1] == w)
							{
								r = w;
								break;
							}
						}
						board[i + 1][j + 1] = 13;
						board[i][j] = 0;
						WhiteCheck();
						if (wCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i + 1][j + 1] = r;
							board[i][j] = 13;
							return;
						}
						i += 100;
						j += 100;
						contw = true;
						cout << "DownRight" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
			}
		}
		if (token != 0)
			break;
	}
}
void BK()
{
	bool qk = false;
	char d = 0;
	int q = 0, a = 0, i = 0, j = 0, z = 0, f = 0, r = 0;
	int up = 0, upl = 0, upr = 0, dn = 0, dl = 0, dr = 0, lt = 0, rt = 0;
	int token = 0;
	cout << "KING:" << endl;
	int count = 0;
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			if (board[i][j] == 29)//(locate)
			{
				//Following if statements disallow the player from moving the king in illegal places, using ints that are assigned to value 1 for every illegal direction
				if (i - 1 < 0)//(boundary)
				{
					count += 3;
					up = 1;
					upl = 1;
					upr = 1;
				}
				if (i + 1 > 7)
				{
					count += 3;
					dn = 1;
					dr = 1;
					dl = 1;
				}
				if (j - 1 < 0)
				{
					count += 3;
					upl = 1;
					lt = 1;
					dl = 1;
				}
				if (j + 1 > 7)
				{
					count += 3;
					upr = 1;
					rt = 1;
					dr = 1;
				}
				for (a = 1; a <= 16; a++)//(friend)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
						{
							count++;
							up = 1;
						}
						if (board[i - 1][j - 1] == a)
						{
							count++;
							upl = 1;
						}
						if (board[i - 1][j + 1] == a)
						{
							count++;
							upr = 1;
						}
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
						{
							count++;
							dn = 1;
						}
						if (board[i + 1][j - 1] == a)
						{
							count++;
							dl = 1;
						}
						if (board[i + 1][j + 1] == a)
						{
							count++;
							dr = 1;
						}
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
						{
							count++;
							lt = 1;
						}
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
						{
							count++;
							rt = 1;
						}
					}
				}
				for (a = 33; a <= 64; a++)
				{
					if (i > 0)
					{
						if (board[i - 1][j] == a)
						{
							count++;
							up = 1;
						}
						if (board[i - 1][j - 1] == a)
						{
							count++;
							upl = 1;
						}
						if (board[i - 1][j + 1] == a)
						{
							count++;
							upr = 1;
						}
					}
					if (i < 7)
					{
						if (board[i + 1][j] == a)
						{
							count++;
							dn = 1;
						}
						if (board[i + 1][j - 1] == a)
						{
							count++;
							dl = 1;
						}
						if (board[i + 1][j + 1] == a)
						{
							count++;
							dr = 1;
						}
					}
					if (j > 0)
					{
						if (board[i][j - 1] == a)
						{
							count++;
							lt = 1;
						}
					}
					if (j < 7)
					{
						if (board[i][j + 1] == a)
						{
							count++;
							rt = 1;
						}
					}
				}
				if (count >= 8)//(grounded)
				{
					cout << "Cannot move" << endl;
					i += 100;
					j += 100;
					return;
				}
				cout << "Direction (q,w,e,a,s,d,z,x,c) :";
				cin >> d;
				if (d == 'p')
					return;
				if (d != 'w' && d != 'a' && d != 'x' && d != 'd' && d != 'q' && d != 'e' && d != 'z' && d != 'c')
				{
					cout << "Error" << endl;
					BK();
				}
				if (d == 'w')
				{
					if (up == 1)
					{
						cout << "Invalid direction" << endl;
						i += 100;
						j += 100;
						BK();
					}
					else
					{
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i - 1][j] == w)
							{
								r = w;
								break;
							}
						}
						board[i - 1][j] = 29;
						board[i][j] = 0;
						BlackCheck();
						if (bCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i - 1][j] = r;
							board[i][j] = 29;
							return;
						}
						i += 100;
						j += 100;
						contb = true;
						cout << "Up" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
				else if (d == 'x')
				{
					if (dn == 1)
					{
						cout << "Invalid direction" << endl;
						i += 100;
						j += 100;
						BK();
					}
					else if (dn == 0)
					{
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i + 1][j] == w)
							{
								r = w;
								break;
							}
						}
						board[i + 1][j] = 29;
						board[i][j] = 0;
						BlackCheck();
						if (bCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i + 1][j] = r;
							board[i][j] = 29;
							return;
						}
						i += 100;
						j += 100;
						contb = true;
						cout << "Down" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
				else if (d == 'a')
				{
					if (lt == 1)
					{
						cout << "Invalid direction" << endl;
						i += 100;
						j += 100;
						BK();
					}
					else if (lt == 0)
					{
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i][j - 1] == w)
							{
								r = w;
								break;
							}
						}
						board[i][j - 1] = 29;
						board[i][j] = 0;
						BlackCheck();
						if (bCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i][j - 1] = r;
							board[i][j] = 29;
							return;
						}
						i += 100;
						j += 100;
						contb = true;
						cout << "Left" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
				else if (d == 'd')
				{
					if (dn == 1)
					{
						cout << "Invalid direction" << endl;
						i += 100;
						j += 100;
						BK();
					}
					else if (dn == 0)
					{
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i][j + 1] == w)
							{
								r = w;
								break;
							}
						}
						board[i][j + 1] = 29;
						board[i][j] = 0;
						BlackCheck();
						if (bCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i][j + 1] = r;
							board[i][j] = 29;
							return;
						}
						i += 100;
						j += 100;
						contb = true;
						cout << "Right" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
				else if (d == 'q')
				{
					if (upl == 1)
					{
						cout << "Invalid direction" << endl;
						f = 5;
						i += 100;
						j += 100;
						BK();
					}
					else if (upl == 0)
					{
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i - 1][j - 1] == w)
							{
								r = w;
								break;
							}
						}
						board[i - 1][j - 1] = 29;
						board[i][j] = 0;
						BlackCheck();
						if (bCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i - 1][j - 1] = r;
							board[i][j] = 29;
							return;
						}
						i += 100;
						j += 100;
						contb = true;
						cout << "UpLeft" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
				else if (d == 'e')
				{
					if (upr == 1)
					{
						cout << "Invalid direction" << endl;
						i += 100;
						j += 100;
						BK();
					}
					else if (upr == 0)
					{
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i - 1][j + 1] == w)
							{
								r = w;
								break;
							}
						}
						board[i - 1][j + 1] = 29;
						board[i][j] = 0;
						BlackCheck();
						if (bCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i - 1][j + 1] = r;
							board[i][j] = 29;
							return;
						}
						i += 100;
						j += 100;
						contb = true;
						cout << "UpRight" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
				else if (d == 'z')
				{
					if (dl == 1)
					{
						cout << "Invalid direction" << endl;
						i += 100;
						j += 100;
						BK();
					}
					else if (dl == 0)
					{
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i + 1][j - 1] == w)
							{
								r = w;
								break;
							}
						}
						board[i + 1][j - 1] = 29;
						board[i][j] = 0;
						BlackCheck();
						if (bCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i + 1][j - 1] = r;
							board[i][j] = 29;
							return;
						}
						i += 100;
						j += 100;
						contb = true;
						cout << "DownLeft" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
				else if (d == 'c')
				{
					if (dr == 1)
					{
						cout << "Invalid direction" << endl;
						i += 100;
						j += 100;
						BK();
					}
					else if (dr == 0)
					{
						for (int w = 0; w < 102; w++)//(checkCheck)
						{
							if (board[i + 1][j + 1] == w)
							{
								r = w;
								break;
							}
						}
						board[i + 1][j + 1] = 29;
						board[i][j] = 0;
						BlackCheck();
						if (bCheck == true)
						{
							cout << "Cannot endanger the king!" << endl;
							board[i + 1][j + 1] = r;
							board[i][j] = 29;
							return;
						}
						i += 100;
						j += 100;
						contb = true;
						cout << "DownRight" << endl;
						i += 100;
						j += 100;
						break;
					}
				}
			}
		}
		if (token != 0)
			break;
	}
}
//Controls the logic for player 1
void Logic1()
{
	contb = false;
	cout << endl;
	display();
	cout << "Player1:" << endl;
	WhiteCheck();//Check if king is in check
	switch (_getch())//Controls the players choice of piece, to display one of multiple display options, or to quit game
	{
	case 'n':
		redacted();
		break;
	case 'm':
		manual();
		break;
	case 'z':
		quitC();
		break;
	case 'l':
		legend();
		break;
	case '1':
		Wp1();
		break;
	case '2':
		Wp2();
		break;
	case '3':
		Wp3();
		break;
	case '4':
		Wp4();
		break;
	case '5':
		Wp5();
		break;
	case '6':
		Wp6();
		break;
	case '7':
		Wp7();
		break;
	case '8':
		Wp8();
		break;
	case 'd':
		Wrr();
		break;
	case 'q':
		Wrl();
		break;
	case 'a':
		Wbr();
		break;
	case 'e':
		Wbl();
		break;
	case 's':
		Wnr();
		break;
	case 'w':
		Wnl();
		break;
	case 'r':
		WQ();
		break;
	case 't':
		WK();
		break;
	default:
		break;
	}
	cout << endl << endl;
}
void Logic2()
{
	contw = false;
	cout << endl;
	display();
	cout << "Player2:" << endl;
	BlackCheck();//Check if king is in check
	switch (_getch())//Controls the players choice of piece, to display one of multiple display options, or to quit game
	{
	case 'n':
		redacted();
		break;
	case 'm':
		manual();
		break;
	case 'z':
		quitC();
		break;
	case 'l':
		legend();
		break;
	case '1':
		Bp1();
		break;
	case '2':
		Bp2();
		break;
	case '3':
		Bp3();
		break;
	case '4':
		Bp4();
		break;
	case '5':
		Bp5();
		break;
	case '6':
		Bp6();
		break;
	case '7':
		Bp7();
		break;
	case '8':
		Bp8();
		break;
	case 'd':
		Brr();
		break;
	case 'q':
		Brl();
		break;
	case 'a':
		Bbr();
		break;
	case 'e':
		Bbl();
		break;
	case 's':
		Bnr();
		break;
	case 'w':
		Bnl();
		break;
	case 'r':
		BQ();
		break;
	case 't':
		BK();
		break;
	default:
		break;
	}
	cout << endl << endl;
}const int Brows = 10;
const int Bcolumns = 10;
string zeplin[rows][columns];
int n, m, o;
char r;
bool quitS;
const int widthS = 32;
const int heightS = 22;
int c, v, fruitX, fruitY, scoreS;
int tailX[100], tailY[100];
int nTail;
enum eDirection { STOP = 0, LEFT, RIGHT, UP, DOWN };
eDirection dir;
//Snake:
//Clears the screen of all previously visible items
void clearS()
{
	cout << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl
		<< endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl
		<< endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl
		<< endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl <<
		endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl <<
		endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl <<
		endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl;
}
void setupS() // Introduces Snake, prompts player to set map size and speed of snake, and to select game mode
{
	/*cout << "Enter your map size. Please enter a numeric value. A small map is 15x15." << "Enter your width: ";
	cin >> n;
	cout << "Enter your height: ";
	cin >> m;
	*/
	clearS();
	cout << "Enter your difficulty (speed)" << endl << "1 (slowest) to 5 (fast) or type any other key for max speed! : ";
	cin >> o;
	clearS();
	cout << "Enter 'f' to play Freemode. No out of bounds however " <<
		"remember that you can still lose by eating your tail!" << endl << endl << "Move your snake with a, s, d, and w and try to eat" <<
		"as many fruits as possible." << endl << "For Regular mode: remember not to go out of bounds or eat your own tail!"
		<< endl << "Ready? Press any key to continue for regular mode, otherwise type 'f' for freemode" << endl;
	cin >> r;
	quitS = false;
	dir = STOP;
	c = widthS / 2;
	v = heightS / 2;
	fruitX = rand() % widthS;
	fruitY = rand() % heightS;
	scoreS = 0;
}
//Handles the visual aspect of the game
void drawS()
{
	system("cls");
	for (int i = 0; i < widthS + 2; i++)
		cout << '\xB2';
	cout << endl;
	for (int i = 0; i < heightS; i++)
	{
		for (int j = 0; j < widthS; j++)
		{
			if (j == 0)
				cout << '\xB2';
			if (i == v && j == c)
				cout << 'O';
			else if (i == fruitY && j == fruitX)
				cout << '\x24';
			else
			{
				bool print = false;
				for (int k = 0; k < nTail; k++)
				{
					if (tailX[k] == j && tailY[k] == i)
					{
						cout << 'o';
						print = true;
					}
				}
				if (!print)
					cout << ' ';
			}
			if (j == widthS - 1)
				cout << '\xB2';
		}
		cout << endl;
	}
	for (int i = 0; i < widthS + 2; i++)
		cout << '\xB2';
	cout << endl;
	cout << "SCORE: " << scoreS << endl;
}
//Defines the input function for the player to control the snake
void inputS()
{
	if (_kbhit())
	{
		switch (_getch())
		{
		case 'a':
			dir = LEFT;
			break;
		case 's':
			dir = DOWN;
			break;
		case 'w':
			dir = UP;
			break;
		case 'd':
			dir = RIGHT;
			break;
		case 'q':
			quitS = true;
			break;
		}
	}
}
//Defines parameters from which the game will operate
void logicS()
{
	int prevX = tailX[0];
	int prevY = tailY[0];
	tailX[0] = c;
	tailY[0] = v;
	int prev2x, prev2y;
	for (int i = 1; i < nTail; i++) //Defines the output for the snake's tail
	{
		prev2x = tailX[i];
		prev2y = tailY[i];
		tailX[i] = prevX;
		tailY[i] = prevY;
		prevX = prev2x;
		prevY = prev2y;
	}
	switch (dir)
	{
	case LEFT:
		c--;
		break;
	case RIGHT:
		c++;
		break;
	case UP:
		v--;
		break;
	case DOWN:
		v++;
		break;
	default:
		break;
	}
	if (r == 'f') //Allows for freemode, walls are passable
	{
		if (c >= widthS) c = 0; else if (c < 0) c = widthS - 1;
		if (v >= heightS) v = 0; else if (v < 0) v = heightS - 1;
	}
	else //This statement defines wall boundary
	{
		if (c > widthS || c < 0 || v > heightS || v < 0)
			quitS = true;
	}
	{
		for (int i = 0; i < nTail; i++)  //Sets quit to true if snake intersects with the tail
			if (tailX[i] == c && tailY[i] == v)
				quitS = true;
	}
	if (c == fruitX && v == fruitY) //Defines the score counter
	{
		scoreS += 10;
		fruitX = rand() % widthS;
		fruitY = rand() % heightS;
		nTail++;
	}
}
//Battleship:
//const int rows = 10;
//const int columns = 10;
int defMaxShips1 = 2;
int defMaxShips2 = 4;
int defMaxShips3 = 5;
int matrix[rows][columns];
//string z[rows][columns];
char a, b;
int x, y, i, j;
//Prompts the setter of the instructions
void startSB()
{
	cout << "WELCOME TO BATTLESHIP!" << endl << "Enter the coordinates of your ships. With default settings your first two ships will be vertically"
		<< endl << "oriented cruisers with a length of two units. Your next set of two ships will be horizontally oriented" << endl <<
		"destroyers with a length of three units.Your final ship will be a horizontally oriented battleship" << endl <<
		"with a length of four units. You will enter your ships by entering the primary coordinate (the coordinate" << endl <<
		"at the uppermost or leftmost portion of the ship. After confirming your coordinates," << endl <<
		"pass control to your opponent. Remember: coordinates are entered (x,y) starting with 0." << endl <<
		"Are you ready? Enter 'y' to start." << endl;
	char q;
	cin >> q;
	if (q != 'y')
	{
		startSB();
	}
}
//Prompts attacker of instructions.
void startA()
{
	char w;
	cout << "Attacker: Once the coordinates have been set, you will be given 20 false attempts to destroy as many enemy ships" << endl <<
		"as possible. There are five ships with different orientations and length by default. You will not be penalized" << endl <<
		"for inputting the same coordinates twice. Remember: coordinates are entered (x,y) starting with 0. Good luck!" << endl <<
		"Enter c to continue" << endl;
	cin >> w;
	if (w != 'c') {
		startA();
	}
}
//Records hits by turning 1’s into 7’s, records misses by turning 0’s into 4’s.
bool attackB(int x, int y)
{
	if (matrix[x][y] == 1) {
		matrix[x][y] = 7;
		//cout << "\a";
		return true;
	}
	else if (matrix[x][y] == 0 || matrix[x][y] == 4) {
		matrix[x][y] = 4;
		return false;
	}
}
//Prompts setter to choose default or custom settings.
bool setCustOrDef()
{
	cout << "Would you like to play with default settings or custom? Type D for Default or C for Custom board.";
	cin >> a;
	if (a != 'd' && a != 'c') {
		setCustOrDef();
	}
	if (a == 'c') {
		return true;
	}
	else return false;
}
//Clears the board of all ships, score values, and misses
void clearB()
{
	for (i = 0; i < rows; i++) {
		for (j = 0; j < columns; j++) {
			matrix[i][j] = 0;
		}
	}
}
//Displays all values of the board
void showB()
{
	for (i = 0; i < rows; i++) {
		for (j = 0; j < columns; j++) {
			cout << setw(10) << matrix[i][j] << " ";
		}
		cout << endl << endl << endl << endl;
	}
}
//Hides from view all previously visible items
void hideB()
{
	cout << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl
		<< endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl
		<< endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl
		<< endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl
		<< endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl << endl;
}
//Counts total number of remaining ships and hits and returns that number, used in the term function.
int totalB()
{
	int tot = 0;
	for (int x = 0; x < 10; x++) {
		for (int y = 0; y < 10; y++) {
			if (matrix[x][y] == 1 || matrix[x][y] == 7) {
				tot++;
			}
		}
	}
	return tot;
}
//Allows setter to set number of misses to loss and returns that value.
int missesB()
{
	int m;
	cout << "Enter # of misses to loss. Recommended 20 for a standard board of approximately 5 ships or 15 units.";
	cin >> m;
	return m;
}
/*Allows the setter to set ships to the board. maxShips1 represents the two cruisers (vertically oriented, length of 2), maxShips2
represents the two destroyers (horizontally oriented, length of 3), and maxShips3 represents the horizontally oriented battleship (length of 4).*/
void setDefShips()
{
	cout << "Set your ships: " << endl;
	int s = 0;
	while (s < defMaxShips1) {
		cin >> y >> x;
		if (matrix[x][y] == 0 && matrix[x + 1][y] == 0) {
			s++;
			matrix[x][y] = 1;
			matrix[x + 1][y] = 1;
			showB();
		}
	}
	while (s < defMaxShips2) {
		cin >> y >> x;
		if (matrix[x][y] == 0 && matrix[x][y + 1] == 0) {
			s++;
			matrix[x][y] = 1;
			matrix[x][y + 1] = 1;
			matrix[x][y + 2] = 1;
			showB();
		}
	}
	while (s < defMaxShips3) {
		cin >> y >> x;
		if (matrix[x][y] == 0 && matrix[x][y + 1] == 0 && matrix[x][y + 2] == 0 && matrix[x][y + 3] == 0) {
			s++;
			matrix[x][y] = 1;
			matrix[x][y + 1] = 1;
			matrix[x][y + 2] = 1;
			matrix[x][y + 3] = 1;
			showB();
		}
	}
}
//Prompts setter to proceed or re-enter coordinates.
void proceedB()
{
	char a, b;
	cout << "Here is your layout. To proceed to attacks enter Y. Otherwise enter N. (if 2nd message, press N to re-enter again)";
	cin >> a;
	if (a == 'n') {
		clearB();
		showB();
		cout << "_________________________" << endl;
		cout << "Please reenter your coordinates" << endl;
		setDefShips();
		cout << "Here is your layout. To proceed to attacks enter Y. Otherwise enter N.";
		cin >> b;
		if (b == 'n') {
			proceedB();
		}
	}
}
//Keeps track of hits with a score counter.
void scoreB() {
	int c = 0;
	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < columns; j++) {
			if (matrix[i][j] == 7)
				c++;
		}
	}
	cout << " score: " << c << endl;
}
//Tests the board to see if 20 misses have been recorded. Attackers are not penalized for duplicate attacks.
bool term() {
	int k = 14, p = 0, e = 0;
	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < columns; j++) {
			if (matrix[i][j] == 4)
				p++;
		}
	}
	if (p == 20) {
		int c = 0;
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < columns; j++) {
				if (matrix[i][j] == 7)
					c++;
			}
		}
		cout << "Final Score: " << c;
		return true;
	}
	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < columns; j++) {
			if (matrix[i][j] == 7) {
				e++;
			}
		}
		if (totalB() - e == 0)
		{
			cout << "You Won!!!";
			return true;
		}
	}
	return false;
}
//Shows modified board for hits, misses, and unknowns.
void showA()
{
	for (i = 0; i < rows; i++) {
		for (j = 0; j < columns; j++) {
			if (matrix[i][j] == 0 || matrix[i][j] == 1) {
				zeplin[i][j] = "X";
			}
			else if (matrix[i][j] == 4) {
				zeplin[i][j] = "\\|/";
			}
			else if (matrix[i][j] == 7) {
				zeplin[i][j] = "<<O>>";
			}
			cout << setw(10) << zeplin[i][j];
		}
		cout << endl << endl << endl << endl;
	}
}
//Displays legend.
void legendB()
{
	cout << " Legend: " << endl << " <<O>> : Hit" << endl << " \\|/ : Miss" << endl << " X : Invisible" << endl << endl;
}
//Counts and displays number of remaining turns.
void remainB()
{
	int d = 0;
	for (i = 0; i < rows; i++) {
		for (j = 0; j < columns; j++) {
			if (zeplin[i][j] == "\\|/")
				d++;
		}
	}
	int rem = 20 - d;
	cout << " Turns left: " << rem << endl << endl;
}
//Allows setter to set a custom number and orientation of ships, up to the maximum board space. Then attacker is prompted; game is defined separately in function.
void setCustomShips()
{
	int a, s, d, f, g;
	cout << "Enter a maximum number of units, for the standard 10x10 board it is recommended to keep it below 25"
		<< endl << "Overflow: ";
	cin >> f;
	if (f > rows * columns)
	{
		setCustomShips();
	}
	cout << "Set number of ships. Be careful not to surpass overflow" << endl << "Cruisers: ";
	cin >> a;
	if ((a * 2) > f)
	{
		a = 0;
		setCustomShips();
	}
	cout << endl << "Destroyers: ";
	cin >> s;
	if ((a * 2 + s * 3) > f)
	{
		a = 0;
		s = 0;
		setCustomShips();
	}
	cout << endl << "Battleships: ";
	cin >> d;
	if ((a * 2 + s * 3 + d * 4) > f)
	{
		a = 0;
		s = 0;
		d = 0;
		setCustomShips();
	}
	cout << "Commence ship setting. Any ship that overlaps or runs off board will be discarded and a new ship will have to be entered." << endl;
	int q = 0, w = 0, e = 0;
	char r, t, u;
	while (q < a)
	{
		char o;
		cout << "Cruiser Orientation (v or h) *default vertical : ";
		cin >> o;
		cout << "Cruiser Primary Coordinates (x,y) : ";
		cin >> y >> x;
		if (o != 'h')
		{
			if (matrix[x][y] == 0 && matrix[x + 1][y] == 0)
			{
				int c[2];
				int d[2];
				int f[2];
				q++;
				matrix[x][y] = 1;
				matrix[x + 1][y] = 1;
				/*c = matrix[x][y];        //Would allow for addition of matrices, which would be used to determine if a whole ship has been destroyed.
				d = matrix[x + 1][y];
				f = c + d;*/
				showB();
			}
		}
		else if (matrix[x][y] == 0 && matrix[x][y + 1] == 0)
		{
			q++;
			matrix[x][y] = 1;
			matrix[x][y + 1] = 1;
			showB();
		}
	}
	while (w < s)
	{
		char o;
		cout << "Destroyer Orientation (v or h) *default horizontal : ";
		cin >> o;
		cout << "Destroyer Primary Coordinates (x,y) : ";
		cin >> y >> x;
		if (o != 'v')
		{
			if (matrix[x][y] == 0 && matrix[x][y + 1] == 0 && matrix[x][y + 2] == 0)
			{
				w++;
				matrix[x][y] = 1;
				matrix[x][y + 1] = 1;
				matrix[x][y + 2] = 1;
				showB();
			}
		}
		else if (matrix[x][y] == 0 && matrix[x + 1][y] == 0 && matrix[x + 2][y] == 0)
		{
			w++;
			matrix[x][y] = 1;
			matrix[x + 1][y] = 1;
			matrix[x + 2][y] = 1;
			showB();
		}
	}
	while (e < d)
	{
		char o;
		cout << "Battleship Orientation (v or h) *default horizontal : ";
		cin >> o;
		if (o != 'v')
		{
			cout << "Battleship Primary Coordinates (x,y) : ";
			cin >> y >> x;
			if (matrix[x][y] == 0 && matrix[x][y + 1] == 0 && matrix[x][y + 2] == 0 && matrix[x][y + 3] == 0)
			{
				e++;
				matrix[x][y] = 1;
				matrix[x][y + 1] = 1;
				matrix[x][y + 2] = 1;
				matrix[x][y + 3] = 1;
				showB();
			}
		}
		else if (o == 'v')
		{
			cout << "Battleship Primary Coordinates (x,y) : ";
			cin >> y >> x;
			if (matrix[x][y] == 0 && matrix[x + 1][y] == 0 && matrix[x + 2][y] == 0 && matrix[x + 3][y] == 0)
			{
				e++;
				matrix[x][y] = 1;
				matrix[x + 1][y] = 1;
				matrix[x + 2][y] = 1;
				matrix[x + 3][y] = 1;
				showB();
			}
		}
	}
	char h, j;
	cout << "Here is your layout. To proceed to attacks press any key. Otherwise enter N to reenter ships.";
	cin >> h;
	if (h == 'n') {
		clearB();
		showB();
		cout << "_________________________" << endl;
		cout << "Please reenter your coordinates" << endl;
		clearB();
		setCustomShips();
	}
	hideB();
	cout << "Attacker: Once the coordinates have been set, you will be given 20 false attempts to destroy as many enemy ships" << endl <<
		"as possible. You will not be penalized for inputting the same coordinates twice. Remember: coordinates are entered" << endl <<
		"(x,y) starting with 0. Good luck!" << endl << "Score to beat: " << a * 2 + s * 3 + d * 4 << endl <<
		"Cruisers: " << a << endl << "Destroyers: " << s << endl << "Battleships: " << d << endl;
	int p1, p2; //Define two integers for attack
	while (1) {
		cout << "Enter your attack!"; cin >> p1 >> p2;
		if (attackB(p2, p1))
		{
			cout << endl << endl << "You've hit a ship!" << endl << endl;
			showA();
			scoreB();
			remainB();
			legendB();
			if (term() == true)
				break;
		}
		else
		{
			cout << endl << endl << "You've hit water.." << endl << endl;
			showA();
			scoreB();
			remainB();
			legendB();
			if (term() == true)
				break;
		}
		/*Define a loop such that the attacker enters coordinates to fire. For every hit, or miss, a message is displayed.
		The board is tested for maximum misses or a perfect score under the term() function. If the function returns true,
		the game ends. Attacker board, score, remaining attempts, and legend are displayed. */
	}
}
//Defines the run function for the Battleship
void runB()
{
	{
		hideB();
		clearB(); //Clear board
		startSB(); //Prompt setter
		hideB(); //Clear screen
		showB(); //Display board
		cout << "_______________________________________" << endl; //Used to separate boards
		if (setCustOrDef() == true) {
			setCustomShips();
		}
		else {
			setDefShips(); //Call setter to set their board
			proceedB(); //Prompt setter to confirm or adjust their board
			hideB(); //Clear code from screen for attacker
			startA(); //Prompt attacker
			int p1, p2; //Define two integers for attack
			while (1) {
				cout << "Enter your attack!"; cin >> p1 >> p2;
				if (attackB(p2, p1))
				{
					cout << endl << endl << "You've hit a ship!" << endl << endl;
					showA();
					scoreB();
					remainB();
					legendB();
					if (term() == true)
						break;
				}
				else
				{
					cout << endl << endl << "You've hit water.." << endl << endl;
					showA();
					scoreB();
					remainB();
					legendB();
					if (term() == true)
						break;
				}
				/*Define a loop such that the attacker enters coordinates to fire. For every hit, or miss, a message is displayed.
				The board is tested for maximum misses or a perfect score under the term() function. If the function returns true,
				the game ends. Attacker board, score, remaining attempts, and legend are displayed. */
			}
		}
		/*
		Manual:
		Setter: Enter the coordinates of your ships. With default settings your first two ships will be vertically oriented
		cruisers with a length of two units. Your next set of two ships will be horizontally oriented destroyers with a length
		of three units.Your final ship will be a horizontally oriented battleship= with a length of four units. You will enter
		your ships by entering the primary coordinate (the coordinate at the uppermost or leftmost portion of the ship.)
		After confirming your coordinates, pass control to your opponent. Remember: coordinates are entered (x,y)
		starting with 0. Are you ready? Enter 'y' to start.
		Attacker: Once the coordinates have been set, you will be given 20 false attempts to destroy as many enemy ships as
		possible. There are five ships with different orientations and length by default. You will not be penalized for
		inputting the same coordinates twice. Remember: coordinates are entered (x,y) starting with 0. Good luck!
		Enter c to continue
		*/
	}
}
//Pong:
enum eDir { STOPP = 0, LEFTP = 1, UPLEFT = 2, DOWNLEFT = 3, RIGHTP = 4, UPRIGHT = 5, DOWNRIGHT = 6 };
class cBall {
private:
	int x, y;
	int originalX, originalY;
	eDir direction;
public:
	cBall(int posX, int posY)
	{
		originalX = posX;
		originalY = posY;
		x = posX; y = posY;
		direction = STOPP;
	}
	//Sets components to start position and halts movement
	void ResetP()
	{
		x = originalX; y = originalY;
		direction = STOPP;
	}
	//Sets a direction for the ball
	void changeDirection(eDir d)
	{
		direction = d;
	}
	//Randomizes the direction of the ball for the 6 directions defined
	void randDirection()
	{
		direction = (eDir)((rand() % 6) + 1);
	}
	inline int getX() { return x; }
	inline int getY() { return y; }
	inline eDir getDirection() { return direction; }
	//Defines the movement of the ball for each direction
	void moveP()
	{
		switch (direction)
		{
		case STOPP:
			break;
		case LEFTP:
			x--;
			break;
		case RIGHTP:
			x++;
			break;
		case UPLEFT:
			x--;
			y--;
			break;
		case DOWNLEFT:
			x--;
			y++;
			break;
		case UPRIGHT:
			x++;
			y--;
			break;
		case DOWNRIGHT:
			x++;
			y++;
			break;
		default:
			break;
		}
	}
	friend ostream& operator<<(ostream & o, cBall c)
	{
		o <<
			"Ball [" << c.x << "," << c.y << "][" << c.direction << "]";
		return o;
	}
};
class cPaddle {
private:
	int x, y, startX, startY;
public:
	cPaddle()
	{
		x = y = 0;
	}
	cPaddle(int posX, int posY) : cPaddle()
	{
		startX = posX;
		startY = posY;
		x = posX;
		y = posY;
	}
	inline void ResetP() { x = startX; y = startY; }
	inline int getX() { return x; }
	inline int getY() { return y; }
	inline void moveUp() { y--; }
	inline void moveDown() { y++; }
	friend ostream& operator<<(ostream& o, cPaddle c)
	{
		o <<
			"Paddle [" << c.x << "," << c.y << "]";
		return o;
	}
};
class cGameManager {
private:
	int width, height, score1, score2;
	char up1, down1, up2, down2;
	bool quit;
	cBall* ball;
	cPaddle* player1;
	cPaddle* player2;
public:
	//Defines input for paddle movement, sets initial score to 0, Sets initial positions for paddles and ball
	cGameManager(int w, int h)
	{
		quit = false;
		up1 = 'w';
		up2 = 'i';
		down1 = 's';
		down2 = 'k';
		score1 = score2 = 0;
		width = w;
		height = h;
		ball = new cBall(w / 2, h / 2);
		player1 = new cPaddle(1, h / 2 - 3);
		player2 = new cPaddle(w - 2, h / 2 - 3);
	}
	//Deletes the old ball and old paddles, (to be replaced by new ball and paddles at start positions)
	~cGameManager()
	{
		delete ball, player1, player2;
	}
	//Sets the score counter and resets all components; halts ball movement
	void scoreUp(cPaddle * player)
	{
		if (player == player1)
			score1++;
		else if (player == player2)
			score2++;
		ball->ResetP();
		player1->ResetP();
		player2->ResetP();
	}
	//Defines the visual aspects of the Pong
	void drawP()
	{
		system("cls");
		for (int i = 0; i < width + 2; i++)
			cout << '\xB2';
		cout << endl;
		for (int i = 0; i < height; i++)
		{
			for (int j = 0; j < width; j++)
			{
				int ballX = ball->getX();
				int ballY = ball->getY();
				int player1x = player1->getX();
				int player2x = player2->getX();
				int player1y = player1->getY();
				int player2y = player2->getY();
				if (j == 0)
					cout << '\xB2';
				if (ballX == j && ballY == i)
					cout << "0";
				else if (player1x == j && player1y == i)
					cout << '\xDB';
				else if (player2x == j && player2y == i)
					cout << '\xDB';
				else if (player1x == j && player1y + 1 == i)
					cout << '\xDB';
				else if (player1x == j && player1y + 2 == i)
					cout << '\xDB';
				else if (player1x == j && player1y + 3 == i)
					cout << '\xDB';
				else if (player2x == j && player2y + 1 == i)
					cout << '\xDB';
				else if (player2x == j && player2y + 2 == i)
					cout << '\xDB';
				else if (player2x == j && player2y + 3 == i)
					cout << '\xDB';
				else cout << " ";
				if (j == width - 1)
					cout << '\xB2';
			}
			cout << endl;
		}
		for (int i = 0; i < width + 2; i++)
			cout << '\xB2';
		cout << endl;
		cout << "Score1: " << score1 << endl << "Score2: " << score2 << endl;
	}
	//Defines player input, including paddle movement and an option to quit Pong
	void inputP()
	{
		ball->moveP();
		int ballX = ball->getX();
		int ballY = ball->getY();
		int player1x = player1->getX();
		int player2x = player2->getX();
		int player1y = player1->getY();
		int player2y = player2->getY();
		if (_kbhit())
		{
			char current = _getch();
			if (current == up1)
				if (player1y > 0)
					player1->moveUp();
			if (current == up2)
				if (player2y > 0)
					player2->moveUp();
			if (current == down1)
				if (player1y + 4 < height)
					player1->moveDown();
			if (current == down2)
				if (player2y + 4 < height)
					player2->moveDown();
			if (ball->getDirection() == STOP)
				ball->randDirection();
			if (current == 'q')
				quit = true;
		}
	}
	//Handles the logic: Ball changes direction randomly with respect to which paddle is hit, Score counter increases dependent upon which side of the boundary is hit
	void logicP()
	{
		int ballX = ball->getX();
		int ballY = ball->getY();
		int player1x = player1->getX();
		int player2x = player2->getX();
		int player1y = player1->getY();
		int player2y = player2->getY();
		for (int i = 0; i < 4; i++)
			if (ballX == player1x + 1)
				if (ballY == player1y + i)
					ball->changeDirection((eDir)((rand() % 3) + 4));
		for (int i = 0; i < 4; i++)
			if (ballX == player2x - 1)
				if (ballY == player2y + i)
					ball->changeDirection((eDir)((rand() % 3) + 1));
		if (ballY == height - 1)
			ball->changeDirection(ball->getDirection() == DOWNRIGHT ? UPRIGHT : UPLEFT);
		if (ballY == 0)
			ball->changeDirection(ball->getDirection() == UPRIGHT ? DOWNRIGHT : DOWNLEFT);
		if (ballX == width - 1)
			scoreUp(player1);
		if (ballX == 0)
			scoreUp(player2);
	}
	//Runs Pong
	void runP()
	{
		while (!quit)
		{
			drawP();
			inputP();
			logicP();
		}
	}
};
//CrossTheRoad:
int scoreC, f = 10, d, e, p;
char k, l;
class cPlayerC {
public:
	int x, y;
	cPlayerC(int widthC) { x = widthC / 2; y = 0; }
};
class cLane {
public:
	deque<bool> cars;
	bool right;
	cLane(int widthC)
	{
		for (int i = 0; i < widthC; i++)
			cars.push_front(true);
		right = rand() % 2;
	}
	void moveC()
	{
		if (right)
		{
			if (rand() % d == 1)
				cars.push_front(true);
			else
				cars.push_front(false);
			cars.pop_back();
		}
		else
		{
			if (rand() % d == 1)
				cars.push_back(true);
			else
				cars.push_back(false);
			cars.pop_front();
		}
	}
	bool checkPos(int pos) { return cars[pos]; }
	void changeDirectionC() { right = !right; }
};
class cGameC {
private:
	bool quit;
	int numberOfLanes, width;
	cPlayerC* playerC;
	vector<cLane*> map;
public:
	cGameC(int w = 20, int h = 10)
	{
		numberOfLanes = h;
		width = w;
		quit = false;
		for (int i = 0; i < numberOfLanes; i++)
			map.push_back(new cLane(width));
		playerC = new cPlayerC(width);
	}
	~cGameC()
	{
		delete playerC;
		for (int i = 0; i < map.size(); i++)
		{
			cLane* current = map.back();
			map.pop_back();
			delete current;
		}
	}
	void inputC()
	{
		if (_kbhit())
		{
			char current = _getch();
			if (current == 'a')
				playerC->x--;
			if (current == 'd')
				playerC->x++;
			if (current == 's')
				playerC->y++;
			if (current == 'w')
				playerC->y--;
			if (current == 'q')
				quit = true;
		}
	}
	void logicC()//Defines the logic for Cross the road
	{
		if (playerC->y == numberOfLanes - 1 && f != 2 && scoreC % 3 == 2)//Increases frequency after every 3 scores
			f--;
		if (playerC->y == numberOfLanes - 1)//Increases score for every cross
		{
			scoreC++;
			playerC->y = 0;
			cout << "\x07";
			map[rand() % numberOfLanes]->changeDirectionC();
		}
		for (int i = 1; i < numberOfLanes - 1; i++)//Moves cars according to frequency f and quits game if player is hit
		{
			if (rand() % f == 1)
				map[i]->moveC();
			if (map[i]->checkPos(playerC->x) && playerC->y == i)
				quit = true;
		}
	}
	void drawC()//Draws the Cross the Road board and displays score, frequency, and density of cars
	{
		system("cls");
		for (int i = 0; i < numberOfLanes; i++)
		{
			for (int j = 0; j < width; j++)
			{
				if (i == 0 && (j == 0 || j == width - 1))
					cout << "\x53";
				if (i == numberOfLanes - 1 && (j == 0 || j == width - 1))
					cout << "\x46";
				if (map[i]->checkPos(j) && i != 0 && i != numberOfLanes - 1)
					cout << l;
				else if (playerC->x == j && playerC->y == i)
					cout << k;
				else
					cout << ' ';
			}
			cout << endl;
		}
		cout << "SCORE: " << scoreC << endl;
		if (quit)
			cout << "Game Over" << endl;
		cout << "Frequency:  1:" << f << endl;
		cout << "Density:  1:" << d << endl;
	}
	void runC()//Runs Cross the Road
	{
		while (!quit)
		{
			inputC();
			logicC();
			drawC();
		}
	}
	void startC()//Starts the game of Cross the Road
	{
		int q;
		cout << "Enter difficulty (density of board): 1 (Easy) to 5 (Hard) [Press 8 for extreme or 9 for impossible!]" << endl;
		cin >> q;
		if (q != 1 && q != 2 && q != 3 && q != 4 && q != 5 && q != 8 && q != 9)
			startC();
		if (q == 1)
			d = 16;
		if (q == 2)
			d = 13;
		if (q == 3)
			d = 10;
		if (q == 4)
			d = 7;
		if (q == 5)
			d = 4;
		if (q == 8)
			d = 3;
		if (q == 9)
			d = 2;
		cout << "Choose your character!" << endl;
		cout << "1: " << '\xFE' << endl << "2: " << '\x99' << endl << "3: " << 'V';
		cin >> p;
		if (p == 1)
			k = '\xFE';
		else if (p == 2)
			k = '\x99';
		else if (p == 3)
			k = 'V';
		else
			k = '\x99';
		cout << "Choose the cars!" << endl;
		cout << "1: " << '\xD8' << endl << "2: " << '\xFE' << endl << "3: " << '#';
		cin >> p;
		if (c == 1)
			l = '\xD8';
		else if (p == 2)
			l = '\xFE';
		else if (p == 3)
			l = '#';
		else
			l = '\xD8';
	}
};
bool quitB;
//Universal output to direct player of how to leave game
void quitOption()
{
	cout << "Enter q to enter main menu at any time" << endl << "Type any key to continue";
}
//Directs player to a menu of games, redirects player to menu after game end
void chooseGame()
{
	char c;
	hideB();
	cout << "Choose Your Game: " << endl << "\x2E B: BATTLESHIP" << endl << "\x2E R: CROSS THE ROAD" << endl << "\x2E P: PONG" << endl << "\x2E S: SNAKE" << endl
		<< "\x2E C: CHESS" << endl;
	cin >> c;
	if (c == 's')
	{
		char h;
		quitS = false;
		cout << "Type q to return to main menu in-game." << endl << "Press any key to continue." << endl;
		cin >> h;
		hideB();
		//intro();
		setupS();
		while (!quitS)
		{
			drawS();
			inputS();
			logicS();
			if (o == 1)
				Sleep(50);
			else if (o == 2)
				Sleep(40);
			else if (o == 3)
				Sleep(25);
			else if (o == 4)
				Sleep(10);
			else if (o == 5)
				Sleep(5);
		}
		cout << "Game Over!" << endl << "Press Any Key" << endl;
		char r;
		cin >> r;
		chooseGame();
	}
	else if (c == 'b')
	{
		/*if (_kbhit())
		{
		char currentB = _getch();
		if (currentB == 'q')
		quitB = true;
		}
		while(!quitB)*/
		runB();
		/*cout << "Press Any Key" << endl;
		char r;
		cin >> r;
		chooseGame();*/
	}
	else if (c == 'p')
	{
		hideB();
		system("cls");
		cout << "Move your pong up and down with w and s keys for player 1 or i and k keys for player 2." << endl <<
			"Type q at any time to return to the menu. Press any key to begin:" << endl;
		_getch();
		cGameManager c(40, 20);
		c.runP();
		cout << "Game Over!" << endl << "Press Any Key" << endl;
		char r;
		cin >> r;
		chooseGame();
	}
	else if (c == 'r')
	{
		int w;
		hideB();
		srand(time(NULL));
		cout << "The game will start at a preset frequency and will gradually speed up. Please wait for the board to clear before starting." << endl <<
			" Move with a, s, d, and w keys." << endl << "Enter board length (recommended at least 10):" << endl;
		cin >> w;
		cGameC gameC(35, w);
		gameC.startC();
		quitOption();
		_getch();
		gameC.runC();
		cout << "Game Over!" << endl << "Press Any Key" << endl;
		_getch();
		chooseGame();
	}
	else if (c == 'c')
	{
		manual();//Displays manual at start game
		legend();//Displays legend at start game
		while (quitGame == false)//Continues passing turns until the quitGame boolean is set to true
		{
			while (contw == false)//Player 1 continues until contw is set to true, which occurs when the player finishes their turn
			{
				Logic1();
			}
			while (contb == false)//Player 2 continues until contb is set to true, which occurs when the player finishes their turn
			{
				Logic2();
			}
		}
		chooseGame();
	}
	else
	{
		cout << "Try Again" << endl;
		chooseGame();
	}
}
//bool menu;
int main()
{
	chooseGame();
	return 0;
}
